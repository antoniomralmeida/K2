
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>models: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/antoniomralmeida/k2/internal/models/bin.go (0.0%)</option>
				
				<option value="file1">github.com/antoniomralmeida/k2/internal/models/datainput.go (0.0%)</option>
				
				<option value="file2">github.com/antoniomralmeida/k2/internal/models/ebnf.go (0.0%)</option>
				
				<option value="file3">github.com/antoniomralmeida/k2/internal/models/kbalert.go (0.0%)</option>
				
				<option value="file4">github.com/antoniomralmeida/k2/internal/models/kbattribute.go (5.3%)</option>
				
				<option value="file5">github.com/antoniomralmeida/k2/internal/models/kbattributeobject.go (0.0%)</option>
				
				<option value="file6">github.com/antoniomralmeida/k2/internal/models/kbattributetype.go (100.0%)</option>
				
				<option value="file7">github.com/antoniomralmeida/k2/internal/models/kbclass.go (89.4%)</option>
				
				<option value="file8">github.com/antoniomralmeida/k2/internal/models/kbhistory.go (0.0%)</option>
				
				<option value="file9">github.com/antoniomralmeida/k2/internal/models/kbobject.go (0.0%)</option>
				
				<option value="file10">github.com/antoniomralmeida/k2/internal/models/kbrule.go (0.0%)</option>
				
				<option value="file11">github.com/antoniomralmeida/k2/internal/models/kbsource.go (100.0%)</option>
				
				<option value="file12">github.com/antoniomralmeida/k2/internal/models/kbstack.go (0.0%)</option>
				
				<option value="file13">github.com/antoniomralmeida/k2/internal/models/kbuser.go (0.0%)</option>
				
				<option value="file14">github.com/antoniomralmeida/k2/internal/models/kbworkspace.go (0.0%)</option>
				
				<option value="file15">github.com/antoniomralmeida/k2/internal/models/knowledgebased.go (1.1%)</option>
				
				<option value="file16">github.com/antoniomralmeida/k2/internal/models/literalbin.go (0.0%)</option>
				
				<option value="file17">github.com/antoniomralmeida/k2/internal/models/pair.go (0.0%)</option>
				
				<option value="file18">github.com/antoniomralmeida/k2/internal/models/token.go (0.0%)</option>
				
				<option value="file19">github.com/antoniomralmeida/k2/internal/models/tokentype.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package models

import "github.com/antoniomralmeida/k2/internal/inits"

type BIN struct {
        tokentype        Tokentype
        pcNextCommand    int //TODO: para comando sem parametros dinâmicos deve-se saltar para o proxim comando na execução
        literalbin       LiteralBin
        token            string
        class            *KBClass
        newAttributes    []KBAttribute
        attribute        *KBAttribute
        workspace        *KBWorkspace
        objects          []*KBObject          //TODO: Poderia ser dinâmico? Tempo de execução?
        attributeObjects []*KBAttributeObject //TODO: Poderia ser dinâmico? Tempo de execução?
}

func (b *BIN) GetToken() string <span class="cov0" title="0">{
        return b.token
}</span>

func (b *BIN) GetTokentype() Tokentype <span class="cov0" title="0">{
        return b.tokentype
}</span>

func (b *BIN) setTokenBin() <span class="cov0" title="0">{
        if b.GetTokentype() == Literal </span><span class="cov0" title="0">{
                var ok bool
                if b.literalbin, ok = LiteralBinStr[b.token]; !ok </span><span class="cov0" title="0">{
                        inits.Log("Literal unknown!"+b.GetToken(), inits.Fatal)
                }</span>
        }
}

func (b *BIN) String() string <span class="cov0" title="0">{
        return "token: " + b.token + ", type:" + b.tokentype.String() + ", bin:" + b.literalbin.String()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package models

import (
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
)

type DataInput struct {
        Name    string          `json:"name"`
        Atype   KBAttributeType `json:"atype"`
        Options []string        `json:"options"`
}

func KBGetDataInput() []*DataInput <span class="cov0" title="0">{
        objs := []KBObject{}
        mgm.Coll(new(KBObject)).SimpleFind(&amp;objs, bson.D{})

        ret := []*DataInput{}
        for i := range objs </span><span class="cov0" title="0">{
                for j := range objs[i].Attributes </span><span class="cov0" title="0">{
                        a := &amp;objs[i].Attributes[j]
                        if a.KbAttribute.isSource(FromUser) &amp;&amp; !a.Validity() </span><span class="cov0" title="0">{
                                di := DataInput{Name: a.KbObject.Name + "." + a.KbAttribute.Name, Atype: a.KbAttribute.AType, Options: a.KbAttribute.Options}
                                ret = append(ret, &amp;di)
                        }</span>
                }
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "strings"
        "unicode"

        "github.com/antoniomralmeida/k2/internal/inits"
)

type EBNF struct {
        Rules []*Statement `json:"rules"`
        Base  *Token       `json:"-"`
}

func (e *EBNF) GetBase() *Token <span class="cov0" title="0">{
        return e.Base
}</span>

func (e *EBNF) FindSymbols(str string, both bool) int <span class="cov0" title="0">{
        for i, x := range symbols </span><span class="cov0" title="0">{
                if x.begin == str </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">if x.end == str &amp;&amp; both </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func (e *EBNF) FindOptions(pt *Token, stack *[]*Token, level int) []*Token <span class="cov0" title="0">{
        var ret []*Token
        if level &lt; 10 </span><span class="cov0" title="0">{
                if pt.GetTokentype() == Control &amp;&amp; pt.Token == "." &amp;&amp; len(*stack) &gt; 0 </span><span class="cov0" title="0">{
                        pt = (*stack)[len(*stack)-1]
                        x := (*stack)[:len(*stack)-1]
                        stack = &amp;x
                }</span>

                <span class="cov0" title="0">for _, x := range pt.Nexts </span><span class="cov0" title="0">{
                        if x.GetTokentype() == Control || x.GetTokentype() == Jump </span><span class="cov0" title="0">{
                                for _, k := range e.FindOptions(x, stack, level+1) </span><span class="cov0" title="0">{
                                        if !isElementExist(ret, k) </span><span class="cov0" title="0">{
                                                ret = append(ret, k)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if x.GetTokentype() == Reference </span><span class="cov0" title="0">{
                                *stack = append(*stack, x)
                                n := e.Rules[x.Rule_jump].Tokens[0]
                                for _, k := range e.FindOptions(n, stack, level+1) </span><span class="cov0" title="0">{
                                        if !isElementExist(ret, k) </span><span class="cov0" title="0">{
                                                ret = append(ret, k)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                if !isElementExist(ret, x) </span><span class="cov0" title="0">{
                                        ret = append(ret, x)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return ret</span>
}

func (e *EBNF) newStatement(str string) *Statement <span class="cov0" title="0">{
        var rule Statement
        rule.Id = len(e.Rules) + 1
        rule.Name = strings.Trim(str, " ")
        e.Rules = append(e.Rules, &amp;rule)
        return &amp;rule
}</span>

func (e *EBNF) newToken(rule *Statement, str string, tokentype Tokentype, nexts ...*Token) <span class="cov0" title="0">{
        Token := Token{Id: len(rule.Tokens) + 1, Token: strings.Trim(str, " "), Rule_id: rule.Id, Tokentype: tokentype}
        for _, jump := range nexts </span><span class="cov0" title="0">{
                Token.Nexts = append(Token.Nexts, jump)
        }</span>
        <span class="cov0" title="0">rule.Tokens = append(rule.Tokens, &amp;Token)</span>
}

func (e *EBNF) newJump(node *Token, nexts ...*Token) <span class="cov0" title="0">{
        for _, jump := range nexts </span><span class="cov0" title="0">{
                node.Nexts = append(node.Nexts, jump)
        }</span>
}

func (e *EBNF) ReadToken(Tokenfile string) int <span class="cov0" title="0">{

        file, err := ioutil.ReadFile(Tokenfile)
        if err != nil </span><span class="cov0" title="0">{
                inits.Log("Could not read the file due to this %s error \n"+err.Error(), inits.Fatal)
        }</span>
        <span class="cov0" title="0">ebnf_txt := string(file)
        ebnf_txt = strings.Replace(ebnf_txt, "\r\n", "", -1)
        ebnf_txt = strings.Replace(ebnf_txt, "\\n", "", -1)
        ebnf_txt = strings.Replace(ebnf_txt, "\t", " ", -1)
        for strings.Contains(ebnf_txt, "  ") </span><span class="cov0" title="0">{
                ebnf_txt = strings.Replace(ebnf_txt, "  ", " ", -1)
        }</span>

        <span class="cov0" title="0">rules := strings.Split(ebnf_txt, ".")
        for _, rule := range rules </span><span class="cov0" title="0">{

                var left string
                var right string
                for i := 0; i &lt; len(rule); i++ </span><span class="cov0" title="0">{
                        if rule[i] == '=' </span><span class="cov0" title="0">{
                                left = rule[0:i]
                                right = rule[i:] + "."
                                break</span>
                        }
                }
                <span class="cov0" title="0">if len(left) &gt; 0 </span><span class="cov0" title="0">{
                        var nrule = e.newStatement(left)
                        var inWord = false
                        var inString = false
                        var inRule = false
                        var start = 0
                        for i, c := range right </span><span class="cov0" title="0">{
                                switch </span>{
                                case e.FindSymbols(string(c), true) != -1 || c == ' ' || c == '|':<span class="cov0" title="0">
                                        if inString </span><span class="cov0" title="0">{
                                                if c == '"' </span><span class="cov0" title="0">{
                                                        e.newToken(nrule, right[start:i], Literal)
                                                        inString = false
                                                }</span>
                                        } else<span class="cov0" title="0"> if inWord </span><span class="cov0" title="0">{
                                                var Tokentype = Literal
                                                if inRule </span><span class="cov0" title="0">{
                                                        Tokentype = Reference
                                                }</span>
                                                <span class="cov0" title="0">e.newToken(nrule, right[start:i], Tokentype)
                                                inWord = false
                                                inRule = false</span>
                                        } else<span class="cov0" title="0"> {
                                                if c == '"' </span><span class="cov0" title="0">{
                                                        start = i + 1
                                                        inString = true
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if c != ' ' &amp;&amp; c != '"' &amp;&amp; c != '\'' &amp;&amp; !inString </span><span class="cov0" title="0">{
                                                if c == '|' </span><span class="cov0" title="0">{
                                                        e.newToken(nrule, string(c), Jump)
                                                }</span> else<span class="cov0" title="0"> {
                                                        e.newToken(nrule, string(c), Control)
                                                }</span>
                                        }
                                case unicode.IsLower(c) &amp;&amp; !inWord &amp;&amp; !inString:<span class="cov0" title="0">
                                        start = i
                                        inWord = true</span>
                                case unicode.IsUpper(c) &amp;&amp; !inWord &amp;&amp; !inString:<span class="cov0" title="0">
                                        start = i
                                        inWord = true
                                        inRule = true</span>
                                default:<span class="cov0" title="0"></span>
                                }
                        }
                        <span class="cov0" title="0">e.parsingStatement(nrule)</span>
                }
        }
        <span class="cov0" title="0">errorFatal := false
        for _, r := range e.Rules </span><span class="cov0" title="0">{
                for _, t := range r.Tokens </span><span class="cov0" title="0">{
                        if t.GetTokentype() == Reference </span><span class="cov0" title="0">{
                                t.Rule_jump = e.findRule(t.Token)
                                if t.Rule_jump == -1 </span><span class="cov0" title="0">{
                                        for z := 1; z &lt; t.GetTokentype().Size(); z++ </span><span class="cov0" title="0">{
                                                if t.Token == Tokentype(z).String() </span><span class="cov0" title="0">{
                                                        t.Tokentype = Tokentype(z)
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if t.GetTokentype() == Reference </span><span class="cov0" title="0">{
                                                errorFatal = true
                                                inits.Log("Reference not found! "+t.Token, inits.Error)
                                        }</span>
                                }

                        }
                        <span class="cov0" title="0">if t.Tokentype == Literal </span><span class="cov0" title="0">{
                                if _, ok := LiteralBinStr[t.Token]; !ok </span><span class="cov0" title="0">{
                                        errorFatal = true
                                        inits.Log("Literal not found! "+t.Token, inits.Error)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">if errorFatal == true </span><span class="cov0" title="0">{
                inits.Log("Fatal error(s) in EBNF parsing!", inits.Fatal)

        }</span>
        <span class="cov0" title="0">e.Base = e.Rules[0].Tokens[0]
        data, err := os.Create(Tokenfile + ".json")
        if err != nil </span><span class="cov0" title="0">{
                inits.Log(err, inits.Error)
        }</span> else<span class="cov0" title="0"> {
                io.Copy(data, strings.NewReader(e.String()))
        }</span>
        <span class="cov0" title="0">return 1</span>
}

func (e *EBNF) findClose(rule *Statement, symb int, Token string, i int, level int) int <span class="cov0" title="0">{
        for j := i + 1; j &lt; len(rule.Tokens); j++ </span><span class="cov0" title="0">{
                if rule.Tokens[j].GetTokentype() == Control </span><span class="cov0" title="0">{
                        s := symbols[symb]
                        if rule.Tokens[j].Token == s.end &amp;&amp; level == 0 </span><span class="cov0" title="0">{
                                return j
                        }</span> else<span class="cov0" title="0"> if rule.Tokens[j].Token == s.begin </span><span class="cov0" title="0">{
                                return e.findClose(rule, symb, Token, j, level+1)
                        }</span> else<span class="cov0" title="0"> if rule.Tokens[j].Token == s.end </span><span class="cov0" title="0">{
                                return e.findClose(rule, symb, Token, j, level-1)
                        }</span>
                }
        }
        <span class="cov0" title="0">return -1</span>
}

func (e *EBNF) parsingStatement(rule *Statement) <span class="cov0" title="0">{
        var pairs []PAIR
        inits.Log("Parsing ebnf rule "+rule.Name, inits.Info)
        for i := 0; i &lt; len(rule.Tokens); i++ </span><span class="cov0" title="0">{
                if rule.Tokens[i].GetTokentype() == Control </span><span class="cov0" title="0">{
                        s := e.FindSymbols(rule.Tokens[i].Token, false)
                        if s != -1 </span><span class="cov0" title="0">{
                                c := e.findClose(rule, s, rule.Tokens[i].Token, i, 0)
                                if c == -1 </span><span class="cov0" title="0">{
                                        msg := fmt.Sprint("Parssing erro in Token ", rule.Tokens[i].Token, " #", rule.Tokens[i].Id, s, i)
                                        inits.Log(msg, inits.Fatal)
                                        return
                                }</span>
                                <span class="cov0" title="0">pairs = append(pairs, PAIR{i, c})
                                if rule.Tokens[i].Token == "\"" || rule.Tokens[i].Token == "'" &amp;&amp; c != -1 </span><span class="cov0" title="0">{
                                        i = c + 1
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">for i := 0; i &lt; len(rule.Tokens)-1; i++ </span><span class="cov0" title="0">{
                var p = findPair(pairs, i)
                if rule.Tokens[i].GetTokentype() != Jump </span><span class="cov0" title="0">{
                        e.newJump(rule.Tokens[i], rule.Tokens[i+1])
                }</span> else<span class="cov0" title="0"> {
                        e.newJump(rule.Tokens[i], rule.Tokens[pairs[p].end])
                        e.newJump(rule.Tokens[pairs[p].begin], rule.Tokens[i+1])
                }</span>
                <span class="cov0" title="0">if rule.Tokens[i].Token == "{" </span><span class="cov0" title="0">{
                        e.newJump(rule.Tokens[pairs[p].begin], rule.Tokens[pairs[p].end])
                        e.newJump(rule.Tokens[pairs[p].end], rule.Tokens[pairs[p].begin])
                }</span>
                <span class="cov0" title="0">if rule.Tokens[i].Token == "[" </span><span class="cov0" title="0">{
                        e.newJump(rule.Tokens[pairs[p].begin], rule.Tokens[pairs[p].end])
                }</span>
        }
}

func (e *EBNF) findRule(key string) int <span class="cov0" title="0">{
        for i, r := range e.Rules </span><span class="cov0" title="0">{
                if r.Name == key </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func (e *EBNF) String() string <span class="cov0" title="0">{
        ret, err := json.MarshalIndent(e.Rules, "", "    ")
        inits.Log(err, inits.Error)
        return string(ret)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBAlert struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Message          string               `bson:"message"`
        User             primitive.ObjectID   `bson:"user"`
        Views            []primitive.ObjectID `bson:"views"`
}

func getLastAlerts(user primitive.ObjectID) ([]KBAlert, error) <span class="cov0" title="0">{
        alerts := []KBAlert{}
        opts := options.Find().SetSort(bson.D{{"create_at", -1}}).SetLimit(5)

        err := mgm.Coll(new(KBAlert)).SimpleFind(alerts, bson.M{"$or": bson.A{
                bson.M{"user": user},
                bson.M{"user": ""},
        }}, opts)
        return alerts, err
}</span>

func NewAlert(msg string, email string) error <span class="cov0" title="0">{
        alert := new(KBAlert)
        alert.Message = msg
        if email != "" </span><span class="cov0" title="0">{
                user := new(KBUser)
                err := user.FindOne(bson.D{{Key: "email", Value: email}})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">alert.User = user.ID</span>
        }
        <span class="cov0" title="0">err := alert.Persist()
        return err</span>
}

func (obj *KBAlert) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (obj *KBAlert) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "github.com/asaskevich/govalidator"
        "go.mongodb.org/mongo-driver/bson/primitive"
)

type KBAttribute struct {
        ID               primitive.ObjectID `bson:"id"`
        Name             string             `bson:"name" valid:"length(2|50),required"`
        AType            KBAttributeType    `bson:"atype" valid:"required"`
        KeepHistory      int                `bson:"keephistory" valid:range(0|5000)`             //Numero de historico a manter, 0- manter todos
        ValidityInterval int64              `bson:"validityinterval" valid:range(0|86400000000)` //validade do ultimo valor em microssegudos, 0- sempre
        SimulationID     KBSimulation       `bson:"simulation,omitempty" json:"-"`
        Simulation       string             `bson:"-" json:"simulation"`
        SourcesID        []KBSource         `bson:"sources" valid:"required"`
        Options          []string           `bson:"options,omitempty"`
        Sources          []string           `bson:"-" json:"sources"`
        antecedentRules  []*KBRule          `bson:"-"`
        consequentRules  []*KBRule          `bson:"-"`
}

func (obj *KBAttribute) validate() (bool, error) <span class="cov8" title="1">{
        return govalidator.ValidateStruct(obj)
}</span>

func (a *KBAttribute) addAntecedentRules(r *KBRule) <span class="cov0" title="0">{
        found := false
        for i := range a.antecedentRules </span><span class="cov0" title="0">{
                if a.antecedentRules[i] == r </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                a.antecedentRules = append(a.antecedentRules, r)
        }</span>
}

func (a *KBAttribute) addConsequentRules(r *KBRule) <span class="cov0" title="0">{
        found := false
        for i := range a.consequentRules </span><span class="cov0" title="0">{
                if a.consequentRules[i] == r </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                a.consequentRules = append(a.consequentRules, r)
        }</span>
}

func (a *KBAttribute) isSource(s KBSource) bool <span class="cov0" title="0">{
        for i := range a.SourcesID </span><span class="cov0" title="0">{
                if a.SourcesID[i] == s </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/antoniomralmeida/k2/internal/fuzzy"
        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        mqtt "github.com/eclipse/paho.mqtt.golang"

        "github.com/kamva/mgm/v3"
        "github.com/montanaflynn/stats"
        p "github.com/rafaeljesus/parallel-fn"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "gonum.org/v1/gonum/stat"
)

const (
        topinIn  = "/in"
        topinOut = "/out"
)

type MTQQValue struct {
        TopicPath string `json:"topicpath"`
        Value     any    `json:"value"`
}

type KBAttributeObject struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Attribute        primitive.ObjectID `bson:"attribute_id"  json:"AttributeId"`
        KbObject         *KBObject          `bson:"-" json:"-"`
        KbHistory        *KBHistory         `bson:"-" json:"History"`
        KbAttribute      *KBAttribute       `bson:"-"  json:"Attrinute"`
}

func KBAttributeObjectFactory(obj *KBObject, attr *KBAttribute) *KBAttributeObject <span class="cov0" title="0">{
        a := KBAttributeObject{Attribute: attr.ID}
        obj.Attributes = append(obj.Attributes, a)
        err := obj.Persist()
        if err == nil </span><span class="cov0" title="0">{
                return &amp;a
        }</span> else<span class="cov0" title="0"> {
                inits.Log(err, inits.Fatal)
                return nil
        }</span>
}

func (ao *KBAttributeObject) Validity() bool <span class="cov0" title="0">{
        if ao.KbHistory != nil </span><span class="cov0" title="0">{
                if ao.KbAttribute.ValidityInterval != 0 </span><span class="cov0" title="0">{
                        diff := time.Now().Sub(time.Unix(0, ao.KbHistory.When))
                        if diff.Milliseconds() &gt; ao.KbAttribute.ValidityInterval </span><span class="cov0" title="0">{
                                ao.KbHistory = nil
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (ao *KBAttributeObject) ValueString() (string, float64, KBAttributeType) <span class="cov0" title="0">{
        v, t, tp := ao.Value()
        value := fmt.Sprint(v)
        if tp == KBString || tp == KBList </span><span class="cov0" title="0">{
                value = "\"" + value + "\""
        }</span>
        <span class="cov0" title="0">return value, t, tp</span>
}
func (ao *KBAttributeObject) Value() (any, float64, KBAttributeType) <span class="cov0" title="0">{
        ao.KbHistory.FindLast(bson.D{{Key: "attribute_id", Value: ao.Attribute}})
        if ao.Validity() </span><span class="cov0" title="0">{
                if KBDate == ao.KbAttribute.AType </span><span class="cov0" title="0">{
                        i, _ := strconv.ParseInt(fmt.Sprintf("%v", ao.KbHistory.Value), 10, 64)
                        return time.Unix(0, i), ao.KbHistory.Trust, ao.KbAttribute.AType
                }</span>
                <span class="cov0" title="0">return ao.KbHistory.Value, ao.KbHistory.Trust, ao.KbAttribute.AType</span>
        } else<span class="cov0" title="0"> {
                timeout := time.After(1 * time.Second) // real-time search
                fn1 := func() error </span><span class="cov0" title="0">{
                        for _, r := range ao.KbAttribute.consequentRules </span><span class="cov0" title="0">{ //backward chaining
                                r.Run()
                                if ao.KbHistory != nil </span><span class="cov0" title="0">{ //when find a value (stop)
                                        return nil
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">fn2 := func() error </span><span class="cov0" title="0">{
                        if ao.KbAttribute.isSource(Simulation) </span><span class="cov0" title="0">{
                                switch ao.KbAttribute.SimulationID </span>{
                                case MonteCarlo:<span class="cov0" title="0">
                                        ao.MonteCarlo()</span>
                                case LinearRegression:<span class="cov0" title="0">
                                        ao.LinearRegression()</span>
                                case NormalDistribution:<span class="cov0" title="0">
                                        ao.NormalDistribution()</span>
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">fn3 := func() error </span><span class="cov0" title="0">{
                        if ao.KbAttribute.isSource(IOT) </span><span class="cov0" title="0">{
                                ao.IOTParsing()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                //TODO: testar a execução paralela
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case e := &lt;-p.Run(fn1, fn2, fn3):<span class="cov0" title="0">
                                inits.Log(e, inits.Error)
                                return nil, 0, NotDefined</span>
                        case &lt;-timeout:<span class="cov0" title="0">
                                if ao.KbHistory != nil </span><span class="cov0" title="0">{
                                        return ao.KbHistory.Value, ao.KbHistory.Trust, ao.KbAttribute.AType
                                }</span>
                        }
                }
        }

}
func (attr *KBAttributeObject) getFullName() string <span class="cov0" title="0">{
        return attr.KbObject.Name + "." + attr.KbAttribute.Name
}</span>

func (attr *KBAttributeObject) String() string <span class="cov0" title="0">{
        j, err := json.MarshalIndent(*attr, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (attr *KBAttributeObject) GetMtqqTopic(direction string) string <span class="cov0" title="0">{
        return strings.ToLower(attr.KbObject.Name) + "/" + strings.ToLower(attr.KbAttribute.Name) + direction
}</span>

func (attr *KBAttributeObject) SetValue(value any, source KBSource, trust float64) *KBHistory <span class="cov0" title="0">{
        if attr == nil </span><span class="cov0" title="0">{
                inits.Log("Invalid attribute!", inits.Error)
                return nil
        }</span>
        <span class="cov0" title="0">if !attr.KbAttribute.isSource(source) &amp;&amp; source != Inference </span><span class="cov0" title="0">{
                inits.Log("Invalid attribute source!", inits.Error)
                return nil
        }</span>
        //if IOT is Source, pub MTQQ msg in topic of atrributte of object
        <span class="cov0" title="0">if attr.KbAttribute.isSource(IOT) </span><span class="cov0" title="0">{
                mtqqmsg := MTQQValue{Value: value, TopicPath: attr.GetMtqqTopic(topinOut)}
                json, _ := json.Marshal(mtqqmsg)
                inits.Publish(mtqqmsg.TopicPath, string(json))
        }</span>

        <span class="cov0" title="0">if reflect.TypeOf(value).String() == "string" </span><span class="cov0" title="0">{
                str := fmt.Sprintf("%v", value)
                switch attr.KbAttribute.AType </span>{
                case KBNumber:<span class="cov0" title="0">
                        value, _ = strconv.ParseFloat(str, 64)</span>
                case KBDate:<span class="cov0" title="0">
                        t, err := time.Parse(lib.YYYYMMDD, str)
                        if err == nil </span><span class="cov0" title="0">{
                                value = t.UnixNano()
                        }</span> else<span class="cov0" title="0"> {
                                inits.Log(err, inits.Error)
                                return nil
                        }</span>
                }
        }
        <span class="cov0" title="0">h := KBHistory{Attribute: attr.ID, When: time.Now().UnixNano(), Value: value, Source: source, Trust: trust}
        inits.Log(h.Persist(), inits.Fatal)
        attr.KbHistory = &amp;h
        KBAddStack(attr.KbAttribute.antecedentRules) //  forward chaining

        if attr.KbAttribute.KeepHistory != 0 </span><span class="cov0" title="0">{
                go h.ClearingHistory(attr.KbAttribute.KeepHistory)
        }</span>
        <span class="cov0" title="0">return &amp;h</span>
}

func (attr *KBAttributeObject) LinearRegression() error <span class="cov0" title="0">{
        type PipeValue struct {
                value float64
                when  int64
                trust float64
        }
        inits.Log("LinearRegression...", inits.Info)
        collection := mgm.Coll(new(KBHistory))
        if attr.KbAttribute.AType == KBNumber </span><span class="cov0" title="0">{
                matchStage := bson.D{{Key: "attribute_id", Value: attr.ID}}
                groupStage := bson.D{{Key: "$project", Value: bson.D{{Key: "_id", Value: 0}, {Key: "value", Value: 1}, {Key: "when", Value: 1}, {Key: "trust", Value: 1}}}}
                ret, err := collection.Aggregate(mgm.Ctx(), mongo.Pipeline{matchStage, groupStage}) // Aggregate(ctx,
                inits.Log(err, inits.Error)
                var resp []PipeValue
                err = ret.All(mgm.Ctx(), &amp;resp)
                inits.Log(err, inits.Error)
                if len(resp) &lt;= 2 </span><span class="cov0" title="0">{
                        inits.Log("cannot do linear regression with | C|&lt;=2", inits.Info)
                        return nil
                }</span>
                <span class="cov0" title="0">X := make([]float64, len(resp))
                Y := make([]float64, len(resp))
                T := make([]float64, len(resp))
                for i := range resp </span><span class="cov0" title="0">{
                        X[i] = float64(resp[i].when)
                        Y[i] = resp[i].value
                        T[i] = resp[i].trust
                }</span>
                <span class="cov0" title="0">trust := stat.Mean(T, nil) / 100.0
                alpha, beta := stat.LinearRegression(X, Y, nil, false)
                r2 := stat.RSquared(X, Y, nil, alpha, beta)
                xn := float64(time.Now().UnixNano())
                fx := alpha + xn*beta
                attr.SetValue(fx, KBSource(Simulation), r2*trust*100.0)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (attr *KBAttributeObject) MonteCarlo() error <span class="cov0" title="0">{
        inits.Log("MonteCarlo...", inits.Info)
        if attr.KbAttribute.AType == KBNumber </span><span class="cov0" title="0">{
                collection := mgm.Coll(new(KBHistory))
                matchStage := bson.D{{Key: "attribute_id", Value: attr.ID}}
                groupStage := bson.D{{Key: "$group", Value: bson.D{{Key: "_id", Value: "$attribute_id"},
                        {Key: "avg", Value: bson.D{{Key: "$avg", Value: "$value"}}},
                        {Key: "stdDev", Value: bson.D{{Key: "$stdDevPop", Value: "$value"}}},
                        {Key: "trust", Value: bson.D{{Key: "$avg", Value: "$trust"}}},
                }}}
                ret, err := collection.Aggregate(mgm.Ctx(), mongo.Pipeline{matchStage, groupStage}) // Aggregate(ctx,
                inits.Log(err, inits.Error)
                var results []Pipe
                err = ret.All(mgm.Ctx(), &amp;results)
                inits.Log(err, inits.Error)

                resp := []Pipe{}
                err = ret.All(mgm.Ctx(), &amp;resp)
                inits.Log(err, inits.Error)

                avg := resp[0].avg
                stdDev := resp[0].stdDev
                trust := resp[0].trust
                r := stats.NormPpfRvs(avg, stdDev, 1)[0]
                a := stats.NormPpf(r, avg, stdDev) * (trust / 100.0)
                attr.SetValue(r, KBSource(Simulation), a*100)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (attr *KBAttributeObject) NormalDistribution() error <span class="cov0" title="0">{

        inits.Log("NormalDistribution...", inits.Info)
        if attr.KbAttribute.AType == KBNumber </span><span class="cov0" title="0">{
                collection := mgm.Coll(new(KBHistory))

                matchStage := bson.D{{Key: "attribute_id", Value: attr.ID}}
                groupStage := bson.D{{Key: "$group", Value: bson.D{{Key: "_id", Value: "$attribute_id"},
                        {Key: "avg", Value: bson.D{{Key: "$avg", Value: "$value"}}},
                        {Key: "stdDev", Value: bson.D{{Key: "$stdDevPop", Value: "$value"}}},
                        {Key: "trust", Value: bson.D{{Key: "$avg", Value: "$trust"}}},
                }}}
                ret, err := collection.Aggregate(mgm.Ctx(), mongo.Pipeline{matchStage, groupStage}) // Aggregate(ctx,
                inits.Log(err, inits.Error)
                var results []Pipe
                err = ret.All(mgm.Ctx(), &amp;results)
                inits.Log(err, inits.Error)

                resp := []Pipe{}
                err = ret.All(mgm.Ctx(), &amp;resp)
                inits.Log(err, inits.Error)
                avg, _ := strconv.ParseFloat(fmt.Sprintf("%v", resp[0].avg), 64)
                stdDev, _ := strconv.ParseFloat(fmt.Sprintf("%v", resp[0].stdDev), 64)
                trust, _ := strconv.ParseFloat(fmt.Sprintf("%v", resp[0].trust), 32)
                r := stats.NormPpfRvs(avg, stdDev, 1)[0]
                a := stats.NormPpf(r, avg, stdDev) * (trust / 100.0)
                attr.SetValue(r, KBSource(Simulation), a*100)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (attr *KBAttributeObject) IOTParsing() error <span class="cov0" title="0">{
        inits.Log("IOTParsing...", inits.Info)
        var msgPubHandler mqtt.MessageHandler = func(client mqtt.Client, msg mqtt.Message) </span><span class="cov0" title="0">{
                value := new(MTQQValue)
                err := json.Unmarshal(msg.Payload(), value)
                inits.Log(err, inits.Error)
                if err == nil </span><span class="cov0" title="0">{
                        attr.SetValue(value.Value, IOT, fuzzy.TrustIOT)
                }</span>
        }
        <span class="cov0" title="0">inits.Subscribe(attr.GetMtqqTopic(topinIn), msgPubHandler)
        return nil</span>
}

func (a *KBAttributeObject) InObjects(objs []*KBObject) bool <span class="cov0" title="0">{
        for i := range objs </span><span class="cov0" title="0">{
                if objs[i] == a.KbObject </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func FindAttributeObject(obj *KBObject, attr string) *KBAttributeObject <span class="cov0" title="0">{
        for i := range obj.Attributes </span><span class="cov0" title="0">{
                if obj.Attributes[i].KbAttribute.Name == attr </span><span class="cov0" title="0">{
                        return &amp;obj.Attributes[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func FindAttributeObjectByName(key string) *KBAttributeObject <span class="cov0" title="0">{
        keys := strings.Split(key, ".")
        ao := new(KBObject)
        r := mgm.Coll(ao).FindOne(mgm.Ctx(), bson.D{{"name", keys[0]}, {"attribute.name", key[1]}})
        r.Decode(ao)
        return &amp;ao.Attributes[0]
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import "strings"

type KBAttributeType int

const (
        NotDefined KBAttributeType = iota
        KBString
        KBDate
        KBNumber
        KBList
)

func KBattributeTypeStr(str string) KBAttributeType <span class="cov8" title="1">{
        return attributeTypeMap[strings.ToLower(str)]
}</span>

var attributeTypeMap = map[string]KBAttributeType{
        "string": KBString,
        "date":   KBDate,
        "number": KBNumber,
        "list":   KBList,
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "context"
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        "github.com/asaskevich/govalidator"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBClass struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Name             string             `bson:"name" valid:"length(5|50),required"`
        Icon             string             `bson:"icon"`
        ParentID         primitive.ObjectID `bson:"parent_id,omitempty"`
        Parent           string             `bson:"-" json:"parent"`
        Attributes       []KBAttribute      `bson:"attributes"`
        ParentClass      *KBClass           `bson:"-"`
}

func (obj *KBClass) validateIndex() error <span class="cov8" title="1">{
        cur, err := mgm.Coll(obj).Indexes().List(mgm.Ctx())
        inits.Log(err, inits.Error)
        var result []bson.M
        err = cur.All(context.TODO(), &amp;result)
        if len(result) == 1 </span><span class="cov0" title="0">{
                inits.CreateUniqueIndex(mgm.Coll(obj), "name")
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (obj *KBClass) valitate() (bool, error) <span class="cov8" title="1">{
        return govalidator.ValidateStruct(obj)
}</span>

func KBClassFactoryParent(name, icon string, parentClass *KBClass) (class *KBClass, err error) <span class="cov8" title="1">{
        if parentClass != nil </span><span class="cov8" title="1">{
                class = &amp;KBClass{Name: name, Icon: icon, ParentClass: parentClass, ParentID: parentClass.ID}
        }</span> else<span class="cov8" title="1"> {
                class = &amp;KBClass{Name: name, Icon: icon}
        }</span>
        <span class="cov8" title="1">ok, err := class.valitate()
        inits.Log(err, inits.Error)
        if !ok </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = class.Persist()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return class, nil</span>
}

func KBClassFactory(name, icon, parent string) (class *KBClass, err error) <span class="cov8" title="1">{
        var parentClass *KBClass
        if parent != "" </span><span class="cov8" title="1">{
                parentClass = FindClassByName(parent, true)
                if parentClass == nil </span><span class="cov8" title="1">{
                        inits.Log(lib.ClassNotFoundError, inits.Info)
                        return nil, lib.ClassNotFoundError
                }</span>
        } else<span class="cov8" title="1"> {
                parentClass = nil
        }</span>
        <span class="cov8" title="1">return KBClassFactoryParent(name, icon, parentClass)</span>
}

func (obj *KBClass) AlterClassAddAttribute(name, atype, simulation string, options, sources []string, keephistory int, valitade int64) (attr *KBAttribute, err error) <span class="cov8" title="1">{
        a := KBAttribute{ID: primitive.NewObjectID(),
                Name:             name,
                AType:            KBattributeTypeStr(atype),
                Options:          options,
                Sources:          sources,
                SourcesID:        ToKBSources(sources),
                KeepHistory:      keephistory,
                ValidityInterval: valitade,
                Simulation:       simulation,
                SimulationID:     KBSimulationStr[simulation]}
        ok, err := a.validate()
        inits.Log(err, inits.Error)
        if ok </span><span class="cov8" title="1">{
                obj.Attributes = append(obj.Attributes, a)
                err = obj.Persist()
                if err == nil </span><span class="cov8" title="1">{
                        return &amp;a, nil
                }</span>
                <span class="cov0" title="0">inits.Log(err, inits.Error)</span>
        }
        <span class="cov8" title="1">return nil, err</span>
}

func (obj *KBClass) Persist() error <span class="cov8" title="1">{
        obj.validateIndex()
        return inits.Persist(obj)
}</span>

func (obj *KBClass) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov8" title="1">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (class *KBClass) FindOne(p bson.D) error <span class="cov8" title="1">{
        ret := mgm.Coll(class).FindOne(mgm.Ctx(), p)
        if ret.Err() == nil </span><span class="cov8" title="1">{
                ret.Decode(class)
                return nil
        }</span> else<span class="cov8" title="1"> {
                return lib.ClassNotFoundError
        }</span>
}

func (class *KBClass) Delete() error <span class="cov8" title="1">{
        res := mgm.Coll(class).FindOne(mgm.Ctx(), bson.D{{"parente", class.ID}})
        if res.Err() == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                res = mgm.Coll(new(KBObject)).FindOne(mgm.Ctx(), bson.D{{"class", class.ID}})
                if res.Err() == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        err := mgm.Coll(class).Delete(class)
                        if err == nil </span><span class="cov8" title="1">{
                                restartKB()
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
        }
        <span class="cov0" title="0">return mongo.ErrMultipleIndexDrop</span>
}

func (class *KBClass) String() string <span class="cov8" title="1">{
        j, err := json.MarshalIndent(*class, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (c *KBClass) FindAttributes() []*KBAttribute <span class="cov8" title="1">{
        var ret []*KBAttribute
        if c.ParentClass != nil </span><span class="cov8" title="1">{
                ret = append(ret, c.ParentClass.FindAttributes()...)
        }</span>
        <span class="cov8" title="1">for i := range c.Attributes </span><span class="cov8" title="1">{
                ret = append(ret, &amp;c.Attributes[i])
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (c *KBClass) FindAttribute(name string) *KBAttribute <span class="cov8" title="1">{
        attrs := c.FindAttributes()
        for i, x := range attrs </span><span class="cov8" title="1">{
                if x.Name == name </span><span class="cov8" title="1">{
                        return attrs[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func FindClassByName(nm string, mandatory bool) *KBClass <span class="cov8" title="1">{
        ret := new(KBClass)
        err := ret.FindOne(bson.D{{Key: "name", Value: nm}})
        if err != nil &amp;&amp; mandatory </span><span class="cov8" title="1">{
                inits.Log(err, inits.Error)
                return nil
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func FindAllClasses(sort string) (class *[]KBClass, err error) <span class="cov8" title="1">{
        class = new([]KBClass)
        cursor, err := mgm.Coll(new(KBClass)).Find(mgm.Ctx(), bson.M{}, options.Find().SetSort(bson.D{{Key: sort, Value: 1}}))
        inits.Log(err, inits.Fatal)
        if err == nil </span><span class="cov8" title="1">{
                err = cursor.All(mgm.Ctx(), class)
        }</span>
        <span class="cov8" title="1">return</span>
}

func KBClassCopy(name string, copy *KBClass) (*KBClass, error) <span class="cov8" title="1">{
        if copy == nil </span><span class="cov0" title="0">{
                inits.Log(lib.InvalidClassError, inits.Error)
                return nil, lib.InvalidClassError
        }</span>
        <span class="cov8" title="1">class := *copy
        class.ID = primitive.NilObjectID
        class.Name = name
        for i := range class.Attributes </span><span class="cov8" title="1">{
                class.Attributes[i].ID = primitive.NewObjectID()
        }</span>
        <span class="cov8" title="1">err := class.Persist()
        if err == nil </span><span class="cov8" title="1">{
                _classes = append(_classes, class)
                return &amp;class, nil
        }</span> else<span class="cov0" title="0"> {
                inits.Log(err, inits.Error)
                return nil, err
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBHistory struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Attribute        primitive.ObjectID `bson:"attribute_id"`
        When             int64              `bson:"when"`
        Value            any                `bson:"value"`
        Trust            float64            `bson:"trust,omitempty"`
        Source           KBSource           `bson:"source"`
}

func (obj *KBHistory) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KBHistory) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (h *KBHistory) ClearingHistory(history int) error <span class="cov0" title="0">{

        type PipeCount struct {
                Id    primitive.ObjectID `json:"_id"`
                Count int                `json:"count"`
        }

        Id := h.Attribute
        collection := mgm.Coll(h)
        for </span><span class="cov0" title="0">{
                matchStage := bson.D{{Key: "attribute_id", Value: Id}}
                groupStage := bson.D{{Key: "$group", Value: bson.D{{Key: "_id", Value: "$attribute_id"}, {Key: "count", Value: bson.D{{Key: "$sum", Value: 1}}}}}}
                ret, err := collection.Aggregate(mgm.Ctx(), mongo.Pipeline{matchStage, groupStage})
                inits.Log(err, inits.Error)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">results := []PipeCount{}
                err = ret.All(mgm.Ctx(), &amp;results)
                inits.Log(err, inits.Error)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if results[0].Count &lt;= history </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">todel := KBHistory{}
                collection.FindOne(mgm.Ctx(), bson.D{{Key: "attribute_id", Value: Id}}, options.FindOne().SetSort(bson.D{{Key: "when", Value: 1}})).Decode(&amp;todel)
                if !todel.ID.IsZero() </span><span class="cov0" title="0">{
                        collection.DeleteOne(mgm.Ctx(), bson.D{{Key: "_id", Value: todel.ID}})
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }
}

func (h *KBHistory) FindLast(filter bson.D) error <span class="cov0" title="0">{
        collection := mgm.Coll(h)
        ret := collection.FindOne(mgm.Ctx(), filter, options.FindOne().SetSort(bson.D{{Key: "when", Value: -1}}))
        if ret != nil </span><span class="cov0" title="0">{
                ret.Decode(h)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *KBHistory) String() string <span class="cov0" title="0">{
        j, err := json.MarshalIndent(*h, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import (
        "context"
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBObject struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Name             string              `bson:"name"`
        Class            primitive.ObjectID  `bson:"class_id"`
        Attributes       []KBAttributeObject `bson:"attributes"`
        Bkclass          *KBClass            `bson:"-" json:"Class"`
        parsed           bool                `bson:"-"`
}

func ObjectFactory(class string, name string) *KBObject <span class="cov0" title="0">{
        p := FindClassByName(class, true)
        if p == nil </span><span class="cov0" title="0">{
                inits.Log("Class not found "+class, inits.Error)
                return nil
        }</span>
        <span class="cov0" title="0">o := KBObject{Name: name, Class: p.ID, Bkclass: p}
        for _, x := range p.FindAttributes() </span><span class="cov0" title="0">{
                n := KBAttributeObject{Attribute: x.ID, KbAttribute: x, KbObject: &amp;o}
                o.Attributes = append(o.Attributes, n)
                //_kb.IdxAttributeObjects[n.getFullName()] = &amp;n
        }</span>
        <span class="cov0" title="0">inits.Log(o.Persist(), inits.Fatal)
        //_kb.IdxObjects[name] = &amp;o
        return &amp;o</span>
}

func (obj *KBObject) validateIndex() error <span class="cov0" title="0">{
        cur, err := mgm.Coll(obj).Indexes().List(mgm.Ctx())
        inits.Log(err, inits.Error)
        var result []bson.M
        err = cur.All(context.TODO(), &amp;result)
        if len(result) == 1 </span><span class="cov0" title="0">{
                inits.CreateUniqueIndex(mgm.Coll(obj), "name")
        }</span>
        <span class="cov0" title="0">return err</span>
}

func FindObjectByName(name string) (ret *KBObject) <span class="cov0" title="0">{
        r := mgm.Coll(ret).FindOne(mgm.Ctx(), bson.D{{"name", name}})
        r.Decode(ret)
        return
}</span>

func ObjectFactoryByClass(name string, class *KBClass) *KBObject <span class="cov0" title="0">{
        o := KBObject{Name: name, Class: class.ID, Bkclass: class}
        for _, x := range class.FindAttributes() </span><span class="cov0" title="0">{
                n := KBAttributeObject{Attribute: x.ID, KbAttribute: x, KbObject: &amp;o}
                o.Attributes = append(o.Attributes, n)
                //_kb.IdxAttributeObjects[n.getFullName()] = &amp;n
        }</span>
        <span class="cov0" title="0">inits.Log(o.Persist(), inits.Fatal)
        //_kb.IdxObjects[name] = &amp;o
        return &amp;o</span>
}

func (obj *KBObject) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KBObject) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (o *KBObject) String() string <span class="cov0" title="0">{
        j, err := json.MarshalIndent(*o, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (o *KBObject) Delete() error <span class="cov0" title="0">{

        mgm.Coll(o).Delete(o)

        // Restart KB
        stopKB()
        InitKB()
        return nil
}</span>

func FindAllObjects(filter bson.M, sort string, objs *[]KBObject) error <span class="cov0" title="0">{
        cursor, err := mgm.Coll(new(KBObject)).Find(mgm.Ctx(), filter, options.Find().SetSort(bson.D{{Key: sort, Value: 1}}))
        inits.Log(err, inits.Fatal)
        err = cursor.All(mgm.Ctx(), objs)
        return err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package models

import (
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"
        "unicode"

        "github.com/PaesslerAG/gval"
        "github.com/kamva/mgm/v3"

        "github.com/antoniomralmeida/k2/internal/fuzzy"
        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        "github.com/antoniomralmeida/k2/pkg/cartesian"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBRule struct {
        mgm.DefaultModel  `json:",inline" bson:",inline"`
        Rule              string     `bson:"rule"`
        Priority          byte       `bson:"priority"` //0..100
        ExecutionInterval int        `bson:"interval"`
        Lastexecution     time.Time  `bson:"lastexecution"`
        consequent        int        `bson:"-"`
        inRun             bool       `bson:"-"`
        bkclasses         []*KBClass `bson:"-"`
        bin               []*BIN     `bson:"-"`
}

func RuleFactory(rule string, priority byte, interval int) *KBRule <span class="cov0" title="0">{
        _, bin, err := parsingRule(rule)
        if inits.Log(err, inits.Info) != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">r := KBRule{Rule: rule, Priority: priority, ExecutionInterval: interval}
        inits.Log(r.Persist(), inits.Fatal)
        linkerRule(&amp;r, bin)
        return &amp;r</span>
}

func (r *KBRule) String() string <span class="cov0" title="0">{
        j, err := json.MarshalIndent(*r, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (obj *KBRule) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KBRule) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (r *KBRule) addClass(c *KBClass) <span class="cov0" title="0">{
        found := false
        for i := range r.bkclasses </span><span class="cov0" title="0">{
                if r.bkclasses[i] == c </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                r.bkclasses = append(r.bkclasses, c)
        }</span>
}

func (r *KBRule) GetBins() []*BIN <span class="cov0" title="0">{
        return r.bin
}</span>

func (r *KBRule) Run() (e error) <span class="cov0" title="0">{

        type Value struct {
                value string
                trust float64
                atype KBAttributeType
        }

        if r.inRun </span><span class="cov0" title="0">{ //avoid non-parallel execution of the same rule
                return
        }</span>
        <span class="cov0" title="0">r.inRun = true
        inits.Log("run..."+r.ID.Hex(), inits.Info)

        attrs := make(map[string][]*KBAttributeObject)
        objs := make(map[string][]*KBObject)

        conditionally := false
        expression := ""
        fuzzyexp := ""

oulter:
        //Program counter [pc] – It stores the counter which contains the address of the next instruction that is to be executed for the process.
        for pc := 0; pc &lt; len(r.bin); </span><span class="cov0" title="0">{
                switch r.bin[pc].literalbin </span>{
                case B_unconditionally:<span class="cov0" title="0">
                        conditionally = true</span>
                case B_then:<span class="cov0" title="0">
                        if !conditionally </span><span class="cov0" title="0">{
                                break oulter</span>
                        }
                case B_for:<span class="cov0" title="0">
                        pc++
                        if r.bin[pc].literalbin != B_any </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">pc++
                        if r.bin[pc].tokentype != Class </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token+" KB Class not found!", inits.Error)
                        }</span>

                        <span class="cov0" title="0">if len(r.bin[pc].objects) == 0 </span><span class="cov0" title="0">{
                                return inits.Log("Warning in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token+" no object found!", inits.Info)
                        }</span>

                        <span class="cov0" title="0">if r.bin[pc+1].tokentype == DynamicReference </span><span class="cov0" title="0">{
                                pc++
                        }</span>
                case B_if:<span class="cov0" title="0">

                inner:
                        for </span><span class="cov0" title="0">{

                                pc++
                                for ; r.bin[pc].literalbin == B_open_par; pc++ </span><span class="cov0" title="0">{
                                        expression = expression + r.bin[pc].token
                                        fuzzyexp = fuzzyexp + r.bin[pc].token
                                }</span>
                                <span class="cov0" title="0">if r.bin[pc].literalbin != B_the </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                                }</span>
                                <span class="cov0" title="0">pc++
                                if r.bin[pc].tokentype != Attribute </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                                }</span>

                                <span class="cov0" title="0">if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                                }</span>
                                <span class="cov0" title="0">key := "{{" + r.bin[pc].class.Name + "." + r.bin[pc].token + "}}"
                                expression = expression + key
                                fuzzyexp = fuzzyexp + key
                                attrs[key] = r.bin[pc].attributeObjects
                                objs[key] = r.bin[pc].objects

                                pc++
                                if r.bin[pc].literalbin == B_of </span><span class="cov0" title="0">{
                                        pc++
                                        if r.bin[pc].tokentype != DynamicReference &amp;&amp; r.bin[pc].tokentype != Object </span><span class="cov0" title="0">{
                                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                                        }</span>
                                        <span class="cov0" title="0">pc++</span>
                                }
                                <span class="cov0" title="0">switch r.bin[pc].literalbin </span>{
                                case B_is:<span class="cov0" title="0">
                                        expression = expression + "=="</span>
                                case B_equal:<span class="cov0" title="0">
                                        expression = expression + "=="</span>
                                case B_different:<span class="cov0" title="0">
                                        expression = expression + "!="</span>
                                case B_less:<span class="cov0" title="0">
                                        expression = expression + "&lt;"
                                        pc += 2
                                        if r.bin[pc].literalbin == B_or </span><span class="cov0" title="0">{
                                                expression = expression + "="
                                                pc += 2
                                        }</span>
                                case B_greater:<span class="cov0" title="0">
                                        expression = expression + "&gt;"
                                        pc += 2
                                        if r.bin[pc].literalbin == B_or </span><span class="cov0" title="0">{
                                                expression = expression + "="
                                                pc += 2
                                        }</span>
                                }
                                <span class="cov0" title="0">pc++
                                if r.bin[pc].tokentype == Constant || r.bin[pc].tokentype == Text || r.bin[pc].tokentype == ListType </span><span class="cov0" title="0">{
                                        expression = expression + r.bin[pc].token
                                }</span>
                                <span class="cov0" title="0">pc++
                                for ; r.bin[pc].literalbin == B_close_par; pc++ </span><span class="cov0" title="0">{
                                        expression = expression + r.bin[pc].token
                                        fuzzyexp = fuzzyexp + r.bin[pc].token
                                }</span>

                                <span class="cov0" title="0">switch r.bin[pc].literalbin </span>{
                                case B_then:<span class="cov0" title="0">
                                        break inner</span>
                                case B_and:<span class="cov0" title="0">
                                        pc++
                                        expression = expression + " " + r.bin[pc].token + " "
                                        fuzzyexp = fuzzyexp + " " + r.bin[pc].token + " "</span>
                                case B_or:<span class="cov0" title="0">
                                        pc++
                                        fuzzyexp = fuzzyexp + " " + r.bin[pc].token + " "</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        pc++</span>
                }
        }

        <span class="cov0" title="0">if !conditionally </span><span class="cov0" title="0">{
                cart := cartesian.Cartesian{}
                values := make(map[string][]Value)
                idx2 := []string{}
                for ix := range attrs </span><span class="cov0" title="0">{
                        vls := []Value{}
                        cart.AddItem(ix, len(attrs[ix])-1)
                        for iy := range attrs[ix] </span><span class="cov0" title="0">{
                                v, t, at := attrs[ix][iy].ValueString()
                                vls = append(vls, Value{v, t, at})
                        }</span>
                        <span class="cov0" title="0">values[ix] = vls
                        idx2 = append(idx2, ix)</span>
                }

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        exp := expression
                        fuzzy := fuzzy.FuzzyLogicalInference(fuzzyexp)
                        found, idxs := cart.GetCombination()
                        obs := []*KBObject{}
                        ok := true
                        for key := range attrs </span><span class="cov0" title="0">{
                                if values[key][idxs[key]].value != "" </span><span class="cov0" title="0">{
                                        ok = false
                                        break</span>
                                }
                                <span class="cov0" title="0">exp = strings.Replace(exp, key, string(values[key][idxs[key]].value), -1)
                                trust := fmt.Sprint(values[key][idxs[key]].trust)
                                fuzzy = strings.Replace(fuzzy, key, trust, -1)
                                obs = append(obs, objs[key][idxs[key]])</span>
                        }
                        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                result, err := gval.Evaluate(exp, nil)
                                inits.Log(err, inits.Error)
                                trust, err := gval.Evaluate(fuzzy, nil)
                                inits.Log(err, inits.Error)
                                t, _ := strconv.ParseFloat(fmt.Sprintf("%v", trust), 64)
                                if result == true </span><span class="cov0" title="0">{
                                        r.RunConsequent(obs, t)
                                }</span>
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                r.RunConsequent([]*KBObject{}, 100.0)
        }</span>
        <span class="cov0" title="0">r.Lastexecution = time.Now()
        r.Persist()
        r.inRun = false
        return nil</span>
}

func (r *KBRule) RunConsequent(objs []*KBObject, trust float64) error <span class="cov0" title="0">{
        //Program counter [pc] – It stores the counter which contains the address of the next instruction that is to be executed for the process.

        for pc := r.consequent; pc &lt; len(r.bin); pc++ </span><span class="cov0" title="0">{
                switch r.bin[pc].literalbin </span>{
                case B_inform:<span class="cov0" title="0">
                        attrs := make(map[string][]*KBAttributeObject)
                        cart := cartesian.Cartesian{}
                        pc += 5
                        if r.bin[pc].tokentype != Text </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">txt := ""
                        ok := true
                        for </span><span class="cov0" title="0">{
                                txt = txt + r.bin[pc].token
                                pc++
                                if r.bin[pc].literalbin != B_the </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">if r.bin[pc].tokentype != Attribute </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                                }</span>
                                <span class="cov0" title="0">if r.bin[pc].attributeObjects == nil </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                                }</span>
                                <span class="cov0" title="0">key := "{{" + r.bin[pc].class.Name + "." + r.bin[pc].token + "}}"
                                txt = txt + " " + key + " "
                                attrs[key] = r.bin[pc].attributeObjects
                                cart.AddItem(key, len(attrs[key])-1)

                                pc += 2
                                if r.bin[pc].literalbin == B_the </span><span class="cov0" title="0">{
                                        pc += 2
                                }</span> else<span class="cov0" title="0"> if r.bin[pc].tokentype != DynamicReference </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                                }</span> else<span class="cov0" title="0"> {
                                        if !attrs[key][pc].InObjects(objs) </span><span class="cov0" title="0">{
                                                ok = false
                                        }</span>
                                        <span class="cov0" title="0">pc++</span>
                                }
                                <span class="cov0" title="0">if r.bin[pc].tokentype == Text </span><span class="cov0" title="0">{
                                        txt = txt + " " + r.bin[pc].token
                                        pc++
                                }</span>
                        }
                        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                txtout := txt
                                found, idxs := cart.GetCombination()
                                wks := make(map[primitive.ObjectID]*KBWorkspace)
                                for key := range attrs </span><span class="cov0" title="0">{
                                        ao := attrs[key][idxs[key]]
                                        value, _, _ := ao.ValueString()
                                        txtout = strings.Replace(txtout, key, value, -1)
                                        ws := KBGetWorkspacesFromObject(ao.KbObject)
                                        for w := range ws </span><span class="cov0" title="0">{
                                                wks[ws[w].ID] = ws[w]
                                        }</span>
                                }
                                <span class="cov0" title="0">for k := range wks </span><span class="cov0" title="0">{
                                        wks[k].Posts.Enqueue(txtout)
                                }</span>
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }

                case B_set:<span class="cov0" title="0">
                        pc += 2
                        if r.bin[pc].tokentype != Attribute </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">if r.bin[pc].attributeObjects == nil </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">attrs := r.bin[pc].attributeObjects
                        if r.bin[pc+3].tokentype != Literal &amp;&amp; r.bin[pc+4].tokentype != Literal </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">if r.bin[pc+4].tokentype != Constant &amp;&amp; r.bin[pc+5].tokentype != Constant </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">var v string
                        if r.bin[pc+4].tokentype == Constant </span><span class="cov0" title="0">{
                                pc += 4
                                v = r.bin[pc].token
                        }</span> else<span class="cov0" title="0"> {
                                pc += 5
                                v = r.bin[pc].token
                        }</span>
                        <span class="cov0" title="0">for _, a := range attrs </span><span class="cov0" title="0">{
                                for _, o := range objs </span><span class="cov0" title="0">{
                                        if a.KbObject == o </span><span class="cov0" title="0">{
                                                a.SetValue(v, Inference, trust)
                                        }</span>
                                }
                        }
                case B_create:<span class="cov0" title="0">
                        var baseClass *KBClass
                        var parentClass *KBClass
                        createClass := false

                        pc++
                        if r.bin[pc].tokentype != Literal </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">switch r.bin[pc].literalbin </span>{
                        case B_a:<span class="cov0" title="0"> //Class
                                pc++
                                createClass = true
                                if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token+" KB Class not found!", inits.Error)
                                }</span>
                                <span class="cov0" title="0">pc++
                                if r.bin[pc].tokentype != Literal </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                                }</span>
                                <span class="cov0" title="0">switch r.bin[pc].literalbin </span>{
                                case B_by:<span class="cov0" title="0">
                                        pc += 2
                                        if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token+" KB Class not found!", inits.Error)
                                        }</span>
                                        <span class="cov0" title="0">baseClass = r.bin[pc].class
                                        pc++</span>
                                case B_whose:<span class="cov0" title="0">
                                        pc += 3
                                        if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token+" KB Class not found!", inits.Error)
                                        }</span>
                                        <span class="cov0" title="0">parentClass = r.bin[pc].class
                                        pc++</span>
                                case B_named:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)</span>
                                }

                        case B_an:<span class="cov0" title="0"> //Instance
                                pc += 4
                                if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token+" KB Class not found!", inits.Error)
                                }</span>
                                <span class="cov0" title="0">baseClass = r.bin[pc].class</span>
                        default:<span class="cov0" title="0">
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)</span>
                        }
                        <span class="cov0" title="0">if r.bin[pc].literalbin == B_named </span><span class="cov0" title="0">{
                                pc += 2
                                if createClass </span><span class="cov0" title="0">{
                                        className := r.bin[pc].GetToken()
                                        if baseClass != nil </span><span class="cov0" title="0">{
                                                KBClassCopy(className, baseClass)
                                        }</span> else<span class="cov0" title="0"> {
                                                KBClassFactoryParent(className, "", parentClass)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        objectName := r.bin[pc].GetToken()
                                        ObjectFactoryByClass(objectName, baseClass)
                                }</span>
                        }
                case B_conclude:<span class="cov0" title="0">
                        pc += 6
                        if len(r.bin[pc].attributeObjects) != 1 </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">attributeObject := r.bin[pc].attributeObjects[0]
                        pc += 2
                        attributeObject.SetValue(r.bin[pc].GetToken(), Inference, trust)</span>
                case B_halt:<span class="cov0" title="0">
                        pauseKB()
                        NewAlert(inits.I18n_halt, "")</span> //All users
                case B_transfer:<span class="cov0" title="0">
                        pc++
                        if len(r.bin[pc].objects) == 0 </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token+" KB Class not found!", inits.Error)
                        }</span>
                        <span class="cov0" title="0">obj := r.bin[pc].objects[0]
                        pc += 2
                        if r.bin[pc].workspace == nil </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token+" KB Class not found!", inits.Error)
                        }</span>
                        <span class="cov0" title="0">w := r.bin[pc].workspace
                        w.AddObject(obj, 0, 0)</span>
                case B_alter:<span class="cov0" title="0">
                        pc++
                        if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token+" KB Class not found!", inits.Error)
                        }</span>
                        //alterClass := r.bin[pc].class
                        <span class="cov0" title="0">pc++
                        for r.bin[pc].literalbin == B_add </span><span class="cov0" title="0">{
                                pc++
                                //attributeName := r.bin[pc].token
                                options := []string{}
                                pc += 2
                                atype := r.bin[pc].token
                                if KBattributeTypeStr(atype) == KBList </span><span class="cov0" title="0">{
                                        pc++
                                        for r.bin[pc].literalbin != B_close_par </span><span class="cov0" title="0">{
                                                pc++
                                                options = append(options, r.bin[pc].token)
                                                pc++
                                        }</span>
                                }

                        }

                default:<span class="cov0" title="0">
                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].token, inits.Error)</span>
                }

                //TODO: delete
                //TODO: insert
                //TODO: remove
                //TODO: change
                //TODO: move
                //TODO: rotate
                //TODO: show
                //TODO: hide
                //TODO: alter
                //TODO: focus
                //TODO: invoke

        }
        <span class="cov0" title="0">return nil</span>
}

func FindAllRules(sort string) error <span class="cov0" title="0">{
        collection := mgm.Coll(new(KBRule))
        cursor, err := collection.Find(mgm.Ctx(), bson.M{}, options.Find().SetSort(bson.D{{Key: sort, Value: 1}}))
        inits.Log(err, inits.Fatal)
        err = cursor.All(mgm.Ctx(), _rules)
        return err
}</span>

func parsingRule(cmd string) ([]*Token, []*BIN, error) <span class="cov0" title="0">{
        cmd = strings.Replace(cmd, "\r\n", "", -1)
        cmd = strings.Replace(cmd, "\\n", "", -1)
        cmd = strings.Replace(cmd, "\t", " ", -1)
        for strings.Contains(cmd, "  ") </span><span class="cov0" title="0">{
                cmd = strings.Replace(cmd, "  ", " ", -1)
        }</span>
        <span class="cov0" title="0">inits.Log("Parsing Prodution Rule: "+cmd, inits.Info)
        var inWord = false
        var inString = false
        var inNumber = false
        var start = 0
        var tokens []string
        const endline = '春'
        cmd = cmd + string(endline)
        for i, c := range cmd </span><span class="cov0" title="0">{
                switch </span>{
                case c == '春' || c == ' ' || _ebnf.FindSymbols(string(c), true) != -1:<span class="cov0" title="0">
                        if inNumber &amp;&amp; c != '.' </span><span class="cov0" title="0">{
                                tokens = append(tokens, cmd[start:i])
                                inNumber = false
                        }</span> else<span class="cov0" title="0"> if inString </span><span class="cov0" title="0">{
                                if c == '"' || c == '\'' </span><span class="cov0" title="0">{
                                        tokens = append(tokens, cmd[start:i+1])
                                        inString = false
                                }</span>
                        } else<span class="cov0" title="0"> if inWord </span><span class="cov0" title="0">{
                                tokens = append(tokens, cmd[start:i])
                                inWord = false
                        }</span> else<span class="cov0" title="0"> {
                                if c == '"' || c == '\'' </span><span class="cov0" title="0">{
                                        start = i
                                        inString = true
                                }</span> else<span class="cov0" title="0"> if c != ' ' &amp;&amp; c != '.' &amp;&amp; c != endline </span><span class="cov0" title="0">{
                                        tokens = append(tokens, string(c))
                                }</span>
                        }
                case unicode.IsLower(c) &amp;&amp; !inWord &amp;&amp; !inString &amp;&amp; !inNumber:<span class="cov0" title="0">
                        start = i
                        inWord = true</span>
                case unicode.IsUpper(c) &amp;&amp; !inWord &amp;&amp; !inString &amp;&amp; !inNumber:<span class="cov0" title="0">
                        start = i
                        inWord = true</span>
                case unicode.IsNumber(c) &amp;&amp; !inNumber &amp;&amp; !inString &amp;&amp; !inWord:<span class="cov0" title="0">
                        start = i
                        inNumber = true</span>
                default:<span class="cov0" title="0"></span>
                }
        }
        <span class="cov0" title="0">var pt = _ebnf.GetBase()
        var stack []*Token
        var opts []*Token
        var bin []*BIN
        for _, x := range tokens </span><span class="cov0" title="0">{
                var ok = false
                opts = _ebnf.FindOptions(pt, &amp;stack, 0)
                for _, y := range opts </span><span class="cov0" title="0">{
                        //fmt.Println(x, y)
                        if (y.GetToken() == x) ||
                                (y.GetTokentype() == DynamicReference &amp;&amp; len(x) == 1) ||
                                ((y.GetTokentype() == Object || y.GetTokentype() == Class ||
                                        y.GetTokentype() == Attribute || y.GetTokentype() == Constant ||
                                        y.GetTokentype() == Reference) &amp;&amp; unicode.IsUpper(rune(x[0]))) ||
                                (y.GetTokentype() == Text &amp;&amp; (rune(x[0]) == '\'' || rune(x[0]) == '"') ||
                                        (y.GetTokentype() == Constant &amp;&amp; lib.IsNumber(x))) </span><span class="cov0" title="0">{
                                if y.GetTokentype() == Class </span><span class="cov0" title="0">{
                                        if FindClassByName(x, false) != nil </span><span class="cov0" title="0">{
                                                ok = true
                                        }</span>
                                } else<span class="cov0" title="0"> if y.GetTokentype() == Object </span><span class="cov0" title="0">{
                                        if FindObjectByName(x) != nil </span><span class="cov0" title="0">{
                                                ok = true
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        ok = true
                                }</span>
                                <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                        pt = y
                                        break</span>

                                }
                        }
                }
                <span class="cov0" title="0">if !ok || len(opts) == 0 </span><span class="cov0" title="0">{
                        str := "Compiler error in " + x + " when the expected was: "
                        for _, y := range opts </span><span class="cov0" title="0">{
                                str = str + "... " + y.GetToken()
                        }</span>
                        <span class="cov0" title="0">return opts, nil, errors.New(str)</span>
                }
                <span class="cov0" title="0">code := BIN{tokentype: pt.GetTokentype(), token: x}
                code.setTokenBin()
                if code.tokentype == Literal &amp;&amp; code.literalbin == B_null </span><span class="cov0" title="0">{
                        inits.Log("Literal not found!", inits.Fatal)
                }</span>
                <span class="cov0" title="0">bin = append(bin, &amp;code)</span>
        }
        <span class="cov0" title="0">for _, y := range pt.GetNexts() </span><span class="cov0" title="0">{
                if y.GetToken() == "." &amp;&amp; y.GetTokentype() == Control </span><span class="cov0" title="0">{
                        inits.Log(", compilation successfully!", inits.Info)
                        return nil, bin, nil
                }</span>
        }
        <span class="cov0" title="0">opts = _ebnf.FindOptions(pt, &amp;stack, 0)
        str := "Incomplete sentence when the expected was: "
        for _, y := range opts </span><span class="cov0" title="0">{
                str = str + "... " + y.GetToken()
        }</span>
        <span class="cov0" title="0">return opts, nil, errors.New(str)</span>
}

func linkerRule(r *KBRule, bin []*BIN) error <span class="cov0" title="0">{
        // Find references of objects in KB
        inits.Log("Linking Prodution Rule: "+r.ID.Hex(), inits.Info)
        pauseKB()

        dr := make(map[string]*KBClass)
        consequent := -1
        for j, x := range bin </span><span class="cov0" title="0">{
                switch x.literalbin </span>{
                case B_initially:<span class="cov0" title="0">
                        stack := KBStack{RuleID: r.ID}
                        stack.Persist()</span>
                case B_then:<span class="cov0" title="0">
                        consequent = j
                        r.consequent = j + 1</span>
                }
                <span class="cov0" title="0">switch x.GetTokentype() </span>{
                case Workspace:<span class="cov0" title="0">
                        if bin[j].workspace == nil </span><span class="cov0" title="0">{
                                bin[j].workspace = FindWorkspaceByName(r.bin[j].token)
                        }</span>
                case Object:<span class="cov0" title="0">
                        if len(bin[j].objects) == 0 </span><span class="cov0" title="0">{
                                obj := FindObjectByName(r.bin[j].token)
                                bin[j].objects = append(bin[j].objects, obj)
                        }</span>
                case Class:<span class="cov0" title="0">
                        if bin[j].class == nil </span><span class="cov0" title="0">{
                                c := FindClassByName(x.GetToken(), true)
                                bin[j].class = c
                                objs := []KBObject{}
                                inits.Log(FindAllObjects(bson.M{"class_id": c.ID}, "_id", &amp;objs), inits.Error)
                                for _, y := range objs </span><span class="cov0" title="0">{
                                        bin[j].objects = append(bin[j].objects, &amp;y)
                                }</span>
                        }
                case Attribute:<span class="cov0" title="0">
                        ref := -1
                        if bin[j+1].literalbin == B_of </span><span class="cov0" title="0">{
                                ref = j + 2
                        }</span> else<span class="cov0" title="0"> {
                                for z := j - 1; z &gt;= 0; z-- </span><span class="cov0" title="0">{
                                        if bin[z].GetTokentype() == Object || bin[z].GetTokentype() == Class </span><span class="cov0" title="0">{
                                                ref = z
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if ref != -1 </span><span class="cov0" title="0">{
                                if bin[ref].GetTokentype() == Object </span><span class="cov0" title="0">{
                                        if len(bin[j].objects) == 0 </span><span class="cov0" title="0">{
                                                obj := FindObjectByName(r.bin[j].token)
                                                bin[j].objects = append(bin[j].objects, obj)
                                                bin[j].class = obj.Bkclass
                                        }</span>
                                        <span class="cov0" title="0">bin[j].attribute = bin[ref].class.FindAttribute(x.GetToken())
                                        if len(bin[j].objects) &gt; 0 </span><span class="cov0" title="0">{
                                                atro := FindAttributeObject(bin[ref].objects[0], x.GetToken())
                                                bin[j].attributeObjects = append(bin[j].attributeObjects, atro)
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                } else<span class="cov0" title="0"> if bin[ref].GetTokentype() == Class </span><span class="cov0" title="0">{
                                        c := bin[ref].class
                                        if c == nil </span><span class="cov0" title="0">{
                                                c = FindClassByName(x.GetToken(), true)
                                                bin[ref].class = c
                                        }</span>
                                        <span class="cov0" title="0">bin[j].class = c
                                        bin[j].attribute = c.FindAttribute(x.GetToken())
                                        objs := []KBObject{}
                                        inits.Log(FindAllObjects(bson.M{"class_id": c.ID}, "_id", &amp;objs), inits.Fatal)
                                        for _, y := range objs </span><span class="cov0" title="0">{
                                                obj := &amp;y
                                                bin[j].objects = append(bin[j].objects, obj)
                                                atro := FindAttributeObject(obj, x.GetToken())
                                                bin[j].attributeObjects = append(bin[j].attributeObjects, atro)
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                } else<span class="cov0" title="0"> if bin[ref].GetTokentype() == DynamicReference </span><span class="cov0" title="0">{
                                        c := bin[ref].class
                                        if c == nil </span><span class="cov0" title="0">{
                                                c = dr[bin[ref].token]
                                                bin[ref].class = c
                                        }</span>
                                        <span class="cov0" title="0">if c == nil </span><span class="cov0" title="0">{
                                                return inits.Log("Attribute class not found in KB! "+x.GetToken(), inits.Error)
                                        }</span>
                                        <span class="cov0" title="0">bin[j].attribute = c.FindAttribute(x.GetToken())
                                        objs := []KBObject{}
                                        inits.Log(FindAllObjects(bson.M{"class_id": c.ID}, "_id", &amp;objs), inits.Fatal)
                                        for _, y := range objs </span><span class="cov0" title="0">{
                                                obj := &amp;y
                                                bin[j].objects = append(bin[j].objects, obj)
                                                atro := FindAttributeObject(obj, x.GetToken())
                                                bin[j].attributeObjects = append(bin[j].attributeObjects, atro)
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        } else<span class="cov0" title="0"> {
                                return inits.Log("Attribute not found in KB! "+x.GetToken(), inits.Error)
                        }</span>
                case DynamicReference:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                if consequent == -1 </span><span class="cov0" title="0">{
                                        for z := j - 1; z &gt;= 0; z-- </span><span class="cov0" title="0">{
                                                if bin[z].GetTokentype() == Object || bin[z].GetTokentype() == Class </span><span class="cov0" title="0">{
                                                        bin[j].class = bin[z].class
                                                        bin[j].objects = bin[z].objects
                                                        dr[x.token] = bin[j].class
                                                        break</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> {
                                        for z := consequent - 1; z &gt;= 0; z-- </span><span class="cov0" title="0">{
                                                if bin[z].GetTokentype() == DynamicReference &amp;&amp; bin[z].GetToken() == x.GetToken() </span><span class="cov0" title="0">{
                                                        bin[j].objects = bin[z].objects
                                                        bin[j].class = bin[z].class
                                                        dr[x.token] = bin[j].class
                                                        break</span>
                                                }
                                        }
                                }
                        }

                case Constant:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                if !lib.IsNumber(x.GetToken()) </span><span class="cov0" title="0">{
                                        ok := false
                                        for z := j - 1; z &gt;= 0; z-- </span><span class="cov0" title="0">{
                                                if bin[z].GetTokentype() == Attribute </span><span class="cov0" title="0">{
                                                        if bin[z].attribute != nil </span><span class="cov0" title="0">{
                                                                for _, o := range bin[z].attribute.Options </span><span class="cov0" title="0">{
                                                                        if x.GetToken() == o </span><span class="cov0" title="0">{
                                                                                bin[j].token = "\"" + bin[j].token + "\""
                                                                                ok = true
                                                                                break</span>
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                                                return inits.Log("List option not found in KB! "+x.GetToken(), inits.Error)
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">a := bin[j].attribute
                if a != nil </span><span class="cov0" title="0">{
                        if consequent != -1 </span><span class="cov0" title="0">{
                                a.addConsequentRules(r)
                        }</span> else<span class="cov0" title="0"> {
                                a.addAntecedentRules(r)
                        }</span>
                }
                <span class="cov0" title="0">cl := bin[j].class
                if cl != nil </span><span class="cov0" title="0">{
                        r.addClass(cl)
                }</span>
                <span class="cov0" title="0">for z := range bin[j].objects </span><span class="cov0" title="0">{
                        bin[j].objects[z].parsed = true
                }</span>
        }
        <span class="cov0" title="0">r.bin = bin
        resumeKB()
        _rules = append(_rules, *r)
        return nil</span>
}

func RefreshRules() error <span class="cov0" title="0">{
        inits.Log("RefreshRules...", inits.Info)
        for i := range _objects </span><span class="cov0" title="0">{
                if !_objects[i].parsed </span><span class="cov0" title="0">{
                        for j := range _rules </span><span class="cov0" title="0">{
                                for k := range _rules[j].bkclasses </span><span class="cov0" title="0">{
                                        if _rules[j].bkclasses[k] == _objects[i].Bkclass </span><span class="cov0" title="0">{
                                                _, bin, err := parsingRule(_rules[j].Rule)
                                                if inits.Log(err, inits.Error) != nil </span><span class="cov0" title="0">{
                                                        linkerRule(&amp;_rules[j], bin)
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">_objects[i].parsed = true</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func runStackRules() error <span class="cov0" title="0">{
        inits.Log("RunStackRules...", inits.Info)
        for i := range _rules </span><span class="cov0" title="0">{
                if _rules[i].ExecutionInterval != 0 &amp;&amp; time.Now().After(_rules[i].Lastexecution.Add(time.Duration(_rules[i].ExecutionInterval)*time.Millisecond)) </span><span class="cov0" title="0">{
                        stack := KBStack{RuleID: _rules[i].ID}
                        stack.Persist()
                }</span>
        }

        <span class="cov0" title="0">toRun := RunFromStack()
        for _, r := range toRun </span><span class="cov0" title="0">{
                r.Run()
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package models

type KBSource int8

const (
        Undefined KBSource = iota
        FromUser
        IOT
        Simulation
        Inference
)

var KBSourceStr = map[string]KBSource{
        "":           Undefined,
        "User":       FromUser,
        "IOT":        IOT,
        "Inference":  Inference,
        "Simulation": Simulation,
}

func ToKBSources(sources []string) (ret []KBSource) <span class="cov8" title="1">{
        for i := range sources </span><span class="cov8" title="1">{
                ret = append(ret, KBSourceStr[sources[i]])
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package models

import (
        "time"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type StackStatus byte

const (
        Pending StackStatus = iota
        Running
        Concluded
)

type KBStack struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        RuleID           primitive.ObjectID `bson:"rule_id"`
        Status           StackStatus        `bson:"status"`
}

func (obj *KBStack) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)
}</span>
func (obj *KBStack) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func StackFactory(id primitive.ObjectID) *KBStack <span class="cov0" title="0">{
        stack := new(KBStack)
        stack.RuleID = id
        inits.Log(stack.Persist(), inits.Fatal)
        return stack
}</span>

func KBAddStack(rules []*KBRule) error <span class="cov0" title="0">{
        for _, r := range rules </span><span class="cov0" title="0">{
                StackFactory(r.ID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func RunFromStack() (list []KBRule) <span class="cov0" title="0">{
        mgm.Coll(new(KBStack)).UpdateMany(mgm.Ctx(), bson.D{{Key: "status", Value: Pending}}, bson.D{{"status", Running}, {"update_at", time.Now().UTC()}})
        ret, err := mgm.Coll(new(KBStack)).Distinct(mgm.Ctx(), "rule_id", bson.D{{"status", Running}})
        inits.Log(err, inits.Error)
        oids := make([]primitive.ObjectID, len(ret))
        for _, id := range ret </span><span class="cov0" title="0">{
                oids = append(oids, id.(primitive.ObjectID))
        }</span>
        <span class="cov0" title="0">opts := options.Find().SetSort(bson.D{{Key: "priority", Value: 1}, {Key: "lastexecution", Value: -1}})
        mgm.Coll(new(KBRule)).SimpleFind(list, bson.D{{Key: "$in", Value: oids}}, opts)
        return</span>
}

func StackEndRun() error <span class="cov0" title="0">{
        _, err := mgm.Coll(new(KBStack)).UpdateMany(mgm.Ctx(), bson.D{{"status", Running}}, bson.D{{"status", Concluded}, {"update_at", time.Now().UTC()}})
        return err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import (
        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        "github.com/asaskevich/govalidator"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "golang.org/x/crypto/bcrypt"
)

type KBUser struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Name             string               `bson:"name" valid:"length(5|50)"`
        Email            string               `bson:"email" valid:"email"`
        Hash             []byte               `bson:"hash" json:"-"`
        Profile          KBProfile            `bson:"profile"`
        Workspaces       []primitive.ObjectID `bson:"workspaces"`
        FaceImage        string               `bson:"faceimage"`
}

func (obj *KBUser) valitade() error <span class="cov0" title="0">{
        _, err := govalidator.ValidateStruct(obj)
        return err
}</span>

func (obj *KBUser) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KBUser) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (user *KBUser) FindOne(p bson.D) error <span class="cov0" title="0">{
        err := mgm.Coll(user).First(p, user)
        return err
}</span>

func NewUser(name, email, pwd, image string) (err error) <span class="cov0" title="0">{
        var copy string
        if image != "" </span><span class="cov0" title="0">{
                copy, err = lib.LoadImage(image)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">u := KBUser{Email: email, Name: name, Hash: hash, FaceImage: copy, Profile: Empty}
        return u.Persist()</span>
}

func InitSecurity() <span class="cov0" title="0">{
        user := KBUser{}
        CheckIndexs()
        err := user.FindOne(bson.D{{Key: "profile", Value: Admin}})
        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                pwd := lib.GeneratePassword(12, 1, 3, 2)
                hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost)
                inits.Log(err, inits.Fatal)
                user = KBUser{Name: "Default Admin", Email: "admin@k2.com", Hash: hash, Profile: Admin}
                inits.Log(user.Persist(), inits.Fatal)
                inits.Log("Default Hash "+pwd, inits.Info)
        }</span> else<span class="cov0" title="0"> {
                inits.Log(err, inits.Fatal)
        }</span>
}

func CheckIndexs() <span class="cov0" title="0">{
        coll := mgm.Coll(&amp;KBUser{})
        idx := coll.Indexes()
        ret, err := idx.List(mgm.Ctx())
        inits.Log(err, inits.Fatal)
        var results []interface{}
        err = ret.All(mgm.Ctx(), &amp;results)
        inits.Log(err, inits.Fatal)
        if len(results) == 1 </span><span class="cov0" title="0">{
                inits.CreateUniqueIndex(coll, "email")
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "context"
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        "github.com/antoniomralmeida/k2/pkg/queue"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBWorkspace struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Workspace        string       `bson:"workspace"`
        Top              int          `bson:"top"`
        Left             int          `bson:"left"`
        Width            int          `bson:"width"`
        Height           int          `bson:"height"`
        BackgroundImage  string       `bson:"backgroundimage,omitempty"`
        Objects          []KBObjectWS `bson:"objects"`
        Posts            queue.Queue  `bson:"-"`
}

func WorkspaceFactory(name string, image string) *KBWorkspace <span class="cov0" title="0">{
        copy, err := lib.LoadImage(image)
        if err != nil </span><span class="cov0" title="0">{
                inits.Log(err, inits.Error)
                return nil
        }</span>
        <span class="cov0" title="0">w := KBWorkspace{Workspace: name, BackgroundImage: copy}
        err = w.Persist()
        if err == nil </span><span class="cov0" title="0">{
                _workspaces = append(_workspaces, w)
                return &amp;w
        }</span> else<span class="cov0" title="0"> {
                inits.Log(err, inits.Fatal)
                return nil
        }</span>
}

func (obj *KBWorkspace) validateIndex() error <span class="cov0" title="0">{
        cur, err := mgm.Coll(obj).Indexes().List(mgm.Ctx())
        inits.Log(err, inits.Error)
        var result []bson.M
        err = cur.All(context.TODO(), &amp;result)
        if len(result) == 1 </span><span class="cov0" title="0">{
                inits.CreateUniqueIndex(mgm.Coll(obj), "workspace")
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (obj *KBWorkspace) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KBWorkspace) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (w *KBWorkspace) String() string <span class="cov0" title="0">{
        j, err := json.MarshalIndent(*w, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (w *KBWorkspace) AddObject(obj *KBObject, left, top int) <span class="cov0" title="0">{
        ows := new(KBObjectWS)
        ows.KBObject = obj
        ows.Object = obj.ID
        ows.Left = left
        ows.Top = top
        w.Objects = append(w.Objects, *ows)
        w.Persist()
}</span>

func FindAllWorkspaces(sort string) error <span class="cov0" title="0">{
        cursor, err := mgm.Coll(new(KBWorkspace)).Find(mgm.Ctx(), bson.D{}, options.Find().SetSort(bson.D{{Key: sort, Value: 1}}))
        inits.Log(err, inits.Fatal)
        err = cursor.All(mgm.Ctx(), &amp;_workspaces)
        return err
}</span>

func FindWorkspaceByName(name string) *KBWorkspace <span class="cov0" title="0">{
        for i := range _workspaces </span><span class="cov0" title="0">{
                if _workspaces[i].Workspace == name </span><span class="cov0" title="0">{
                        return &amp;_workspaces[i]
                }</span>
        }
        <span class="cov0" title="0">inits.Log("Workspace not found!", inits.Error)
        return nil</span>
}

func KBWorkspacesJson() string <span class="cov0" title="0">{
        wks := []KBWorkspace{}

        mgm.Coll(new(KBWorkspace)).SimpleFind(&amp;wks, bson.D{{}})
        ret := []WorkspaceInfo{}
        for _, w := range wks </span><span class="cov0" title="0">{
                ret = append(ret, WorkspaceInfo{Workspace: w.Workspace, BackgroundImage: w.BackgroundImage})
        }</span>
        <span class="cov0" title="0">json, err := json.Marshal(ret)
        inits.Log(err, inits.Error)
        return string(json)</span>
}

func KBGetWorkspacesFromObject(o *KBObject) (ret []*KBWorkspace) <span class="cov0" title="0">{
        //TODO: From mongoDB
        for i := range _workspaces </span><span class="cov0" title="0">{
                for j := range _workspaces[i].Objects </span><span class="cov0" title="0">{
                        if _workspaces[i].Objects[j].KBObject == o </span><span class="cov0" title="0">{
                                ret = append(ret, &amp;_workspaces[i])
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "fmt"
        "os"
        "runtime"
        "sort"
        "sync"
        "time"

        "github.com/kamva/mgm/v3"
        "github.com/madflojo/tasks"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"

        "go.mongodb.org/mongo-driver/bson"

        "go.mongodb.org/mongo-driver/bson/primitive"
)

var (
        kb_current  *KnowledgeBased
        scheduler   *tasks.Scheduler
        _classes    []KBClass
        _workspaces []KBWorkspace
        _rules      []KBRule
        _objects    []KBObject
        _ebnf       *EBNF
)

type KnowledgeBased struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Name             string `bson:"name"`
}

func KnowledgeBasedFacotory() *KnowledgeBased <span class="cov0" title="0">{
        kb := new(KnowledgeBased)
        kb.findOne()
        if kb.Name == "" </span><span class="cov0" title="0">{
                kb.Name = "K2 KnowledgeBase System "
        }</span>
        <span class="cov0" title="0">kb.Persist()
        return kb</span>
}

func pauseKB() <span class="cov0" title="0">{
        scheduler.Lock()
}</span>

func resumeKB() <span class="cov0" title="0">{
        if scheduler != nil </span><span class="cov0" title="0">{
                scheduler.Unlock()
        }</span>
}

func stopKB() <span class="cov0" title="0">{
        if scheduler != nil </span><span class="cov0" title="0">{
                scheduler.Stop()
        }</span>
}

func restartKB() <span class="cov8" title="1">{
        if scheduler != nil </span><span class="cov0" title="0">{
                scheduler.Stop()
                InitKB()
        }</span>
}

func (kb *KnowledgeBased) linkObjects(ws *KBWorkspace, obj *KBObject, left int, top int) <span class="cov0" title="0">{
        ows := KBObjectWS{Object: obj.ID, Left: left, Top: top, KBObject: obj}
        ws.Objects = append(ws.Objects, ows)
        inits.Log(ws.Persist(), inits.Fatal)
}</span>

func (kb *KnowledgeBased) updateKB(name string) error <span class="cov0" title="0">{
        kb.Name = name
        return kb.Persist()
}</span>

func (obj *KnowledgeBased) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KnowledgeBased) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (kb *KnowledgeBased) findOne() error <span class="cov0" title="0">{
        ret := mgm.Coll(kb).FindOne(mgm.Ctx(), bson.D{})
        ret.Decode(kb)
        return nil
}</span>

func InitKB() <span class="cov0" title="0">{
        inits.Log("Init KB", inits.Info)
        kb_current = KnowledgeBasedFacotory()

        //Check unique index from database collections
        new(KBClass).validateIndex()
        new(KBWorkspace).validateIndex()
        new(KBObject).validateIndex()

        _ebnf := EBNF{}
        _ebnf.ReadToken("./configs/k2.ebnf")

        FindAllClasses("_id")

        _idxClasses := make(map[primitive.ObjectID]*KBClass)
        for _, c := range _classes </span><span class="cov0" title="0">{
                _idxClasses[c.ID] = &amp;c
        }</span>

        <span class="cov0" title="0">for j, c := range _classes </span><span class="cov0" title="0">{
                inits.Log("Prepare Class "+c.Name, inits.Info)
                if !c.ParentID.IsZero() </span><span class="cov0" title="0">{
                        pc := _idxClasses[c.ParentID]
                        if pc != nil </span><span class="cov0" title="0">{
                                _classes[j].ParentClass = pc
                        }</span> else<span class="cov0" title="0"> {
                                inits.Log("Parent of Class "+c.Name+" not found!", inits.Fatal)
                        }</span>
                }
        }

        <span class="cov0" title="0">FindAllObjects(bson.M{}, "name", &amp;_objects)
        for j, o := range _objects </span><span class="cov0" title="0">{
                //_kb.IdxObjects[o.Name] = &amp;_kb.Objects[j]
                c := _idxClasses[o.Class]
                if c != nil </span><span class="cov0" title="0">{
                        _objects[j].Bkclass = c
                        attrs := c.FindAttributes()
                        sort.Slice(attrs, func(i, j int) bool </span><span class="cov0" title="0">{
                                return attrs[i].ID.Hex() &lt; attrs[j].ID.Hex()
                        }</span>)
                        <span class="cov0" title="0">for k, x := range o.Attributes </span><span class="cov0" title="0">{
                                _objects[j].Attributes[k].KbObject = &amp;_objects[j]
                                //kb.Objects[j].Attributes[k].Kb = kb
                                for l, y := range attrs </span><span class="cov0" title="0">{
                                        if y.ID == x.Attribute </span><span class="cov0" title="0">{
                                                _objects[j].Attributes[k].KbAttribute = attrs[l]
                                                break</span>
                                        }
                                        <span class="cov0" title="0">if y.ID.Hex() &gt; x.Attribute.Hex() </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if _objects[j].Attributes[k].KbAttribute == nil </span><span class="cov0" title="0">{
                                        inits.Log("Attribute not found "+x.Attribute.Hex(), inits.Fatal)
                                }</span>

                                //Last value
                                <span class="cov0" title="0">h := KBHistory{}
                                err := h.FindLast(bson.D{{Key: "attribute_id", Value: x.ID}})
                                if err != nil </span><span class="cov0" title="0">{
                                        if err.Error() != "not found" </span><span class="cov0" title="0">{
                                                inits.Log(err, inits.Fatal)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        _objects[j].Attributes[k].KbHistory = &amp;h
                                }</span>
                                <span class="cov0" title="0">_objects[j].Attributes[k].Validity()</span>
                        }
                } else<span class="cov0" title="0"> {
                        inits.Log("Class of object "+o.Name+" not found!", inits.Fatal)
                }</span>
        }

        <span class="cov0" title="0">FindAllWorkspaces("name")

        FindAllRules("_id")

        for i := range _rules </span><span class="cov0" title="0">{
                _, bin, err := parsingRule(_rules[i].Rule)
                inits.Log(err, inits.Fatal)
                linkerRule(&amp;_rules[i], bin)
        }</span>
}

func KBRun(wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        // Start the Scheduler
        scheduler = tasks.New()
        defer scheduler.Stop()

        // Add tasks
        _, err := scheduler.Add(&amp;tasks.Task{
                Interval: time.Duration(2 * time.Second),

                TaskFunc: func() error </span><span class="cov0" title="0">{
                        go runStackRules()
                        return nil
                }</span>,
        })
        <span class="cov0" title="0">inits.Log(err, inits.Fatal)
        _, err = scheduler.Add(&amp;tasks.Task{
                Interval: time.Duration(60 * time.Second),
                TaskFunc: func() error </span><span class="cov0" title="0">{
                        go RefreshRules()
                        return nil
                }</span>,
        })
        <span class="cov0" title="0">inits.Log(err, inits.Fatal)

        inits.Log("K2 KB System started!", inits.Info)
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                fmt.Println("K2 KB System started! Press ESC to shutdown")
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if lib.KeyPress() == 27 </span><span class="cov0" title="0">{
                        fmt.Printf("Shutdown...")
                        stopKB()
                        wg.Done()
                        os.Exit(0)
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

type LiteralBin byte

const (
        B_null LiteralBin = iota
        B_a
        B_activate
        B_add
        B_alter
        B_an
        B_and
        B_any
        B_are
        B_as
        B_at
        B_blue
        B_breakpoints
        B_by
        B_change
        B_cloning
        B_close_par
        B_comma
        B_conclude
        B_create
        B_date
        B_deactivate
        B_degrees
        B_delete
        B_different
        B_enabled
        B_end
        B_equal
        B_equal_sym
        B_first_task
        B_focus
        B_for
        B_from
        B_greater
        B_green
        B_halt
        B_hide
        B_history
        B_if
        B_inference
        B_inform
        B_initially
        B_insert
        B_instance
        B_invoke
        B_iot
        B_is
        B_keep
        B_less
        B_linearregression
        B_list
        B_method
        B_montecarlo
        B_move
        B_named
        B_normaldistribution
        B_number
        B_of
        B_on
        B_open_par
        B_operator
        B_or
        B_parent
        B_red
        B_remove
        B_rotate
        B_set
        B_show
        B_simulation
        B_start
        B_string
        B_task_queue
        B_than
        B_that
        B_the
        B_then
        B_to
        B_transfer
        B_unconditionally
        B_user
        B_validity
        B_when
        B_whenever
        B_whose
        B_with
        B_yellow
)

var LiteralBinStr = map[string]LiteralBin{
        "":                   B_null,
        "a":                  B_a,
        "activate":           B_activate,
        "add":                B_add,
        "alter":              B_alter,
        "an":                 B_an,
        "and":                B_and,
        "any":                B_any,
        "are":                B_are,
        "as":                 B_as,
        "at":                 B_at,
        "blue":               B_blue,
        "breakpoints":        B_breakpoints,
        "by":                 B_by,
        "change":             B_change,
        "cloning":            B_cloning,
        ")":                  B_close_par,
        ",":                  B_comma,
        "conclude":           B_conclude,
        "create":             B_create,
        "Date":               B_date,
        "deactivate":         B_deactivate,
        "degrees":            B_degrees,
        "delete":             B_delete,
        "different":          B_different,
        "enabled":            B_enabled,
        "end":                B_end,
        "equal":              B_equal,
        "=":                  B_equal_sym,
        "first-task":         B_first_task,
        "focus":              B_focus,
        "for":                B_for,
        "from":               B_from,
        "greater":            B_greater,
        "green":              B_green,
        "halt":               B_halt,
        "hide":               B_hide,
        "history":            B_history,
        "if":                 B_if,
        "Inference":          B_inference,
        "inform":             B_inform,
        "initially":          B_initially,
        "insert":             B_insert,
        "instance":           B_instance,
        "invoke":             B_invoke,
        "IOT":                B_iot,
        "is":                 B_is,
        "keep":               B_keep,
        "less":               B_less,
        "LinearRegression":   B_linearregression,
        "List":               B_list,
        "method":             B_method,
        "MonteCarlo":         B_montecarlo,
        "move":               B_move,
        "named":              B_named,
        "NormalDistribution": B_normaldistribution,
        "Number":             B_number,
        "of":                 B_of,
        "on":                 B_on,
        "(":                  B_open_par,
        "operator":           B_operator,
        "or":                 B_or,
        "parent":             B_parent,
        "red":                B_red,
        "remove":             B_remove,
        "rotate":             B_rotate,
        "set":                B_set,
        "show":               B_show,
        "Simulation":         B_simulation,
        "start":              B_start,
        "String":             B_string,
        "task-queue":         B_task_queue,
        "than":               B_than,
        "that":               B_that,
        "the":                B_the,
        "then":               B_then,
        "to":                 B_to,
        "transfer":           B_transfer,
        "unconditionally":    B_unconditionally,
        "User":               B_user,
        "validity":           B_validity,
        "when":               B_when,
        "whenever":           B_whenever,
        "whose":              B_whose,
        "with":               B_with,
        "yellow":             B_yellow,
}

func (me LiteralBin) String() string <span class="cov0" title="0">{
        return string(me)
}</span>

func (me LiteralBin) Size() int <span class="cov0" title="0">{
        return len(LiteralBinStr)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

type PAIR struct {
        begin int
        end   int
}

func findPair(p []PAIR, i int) int <span class="cov0" title="0">{
        var ret = 0
        for k, x := range p </span><span class="cov0" title="0">{
                if x.begin &lt;= i &amp;&amp; x.end &gt;= i &amp;&amp; (p[k].begin &gt; p[ret].begin || p[k].end &lt; p[ret].end) </span><span class="cov0" title="0">{
                        ret = k
                }</span>
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "strconv"
)

type Token struct {
        Id        int       `json:"id"`
        Tokentype Tokentype `json:"tokentype"`
        Rule_id   int       `json:"rule_id"`
        Rule_jump int       `json:"rule_jump"`
        Token     string    `json:"token"`
        Nexts     []*Token  `json:"-"`
}

func (t *Token) GetToken() string <span class="cov0" title="0">{
        return t.Token
}</span>

func (t *Token) GetTokentype() Tokentype <span class="cov0" title="0">{
        return t.Tokentype
}</span>

func (t *Token) GetNexts() []*Token <span class="cov0" title="0">{
        return t.Nexts
}</span>

func (t *Token) String() string <span class="cov0" title="0">{
        return "#" + strconv.Itoa(t.Id) + ", token: " + t.Token + ", type:" + t.Tokentype.String()
}</span>

func (t *Token) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        var result map[string]string = make(map[string]string)
        result["Id"] = strconv.Itoa(t.Id)
        result["Tokentype"] = t.Tokentype.String()
        result["Rule_id"] = strconv.Itoa(t.Rule_id)
        result["Rule_jump"] = strconv.Itoa(t.Rule_jump)
        result["Token"] = t.Token
        result["Nexts"] = fmt.Sprintf("%v", t.Nexts)
        return json.Marshal(&amp;result)
}</span>

func isElementExist(s []*Token, str *Token) bool <span class="cov0" title="0">{
        for _, v := range s </span><span class="cov0" title="0">{
                if v == str </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package models

type Tokentype byte

const (
        Null Tokentype = iota
        Reference
        Literal
        Text
        Control
        Jump
        Object
        DynamicReference
        Attribute
        Constant
        Class
        ListType
        Workspace
)

var TokentypeStr = []string{"", "Reference", "Literal", "Text", "Control", "Jump", "Object", "DynamicReference", "Attribute", "Constant", "Class", "ListType", "Workspace"}

func (me Tokentype) String() string <span class="cov0" title="0">{
        return TokentypeStr[me]
}</span>

func (me Tokentype) Size() int <span class="cov0" title="0">{
        return len(TokentypeStr)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
