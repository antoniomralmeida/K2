
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>models: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/antoniomralmeida/k2/internal/models/bin.go (100.0%)</option>
				
				<option value="file1">github.com/antoniomralmeida/k2/internal/models/datainput.go (0.0%)</option>
				
				<option value="file2">github.com/antoniomralmeida/k2/internal/models/ebnf.go (92.5%)</option>
				
				<option value="file3">github.com/antoniomralmeida/k2/internal/models/kbalert.go (0.0%)</option>
				
				<option value="file4">github.com/antoniomralmeida/k2/internal/models/kbattribute.go (5.3%)</option>
				
				<option value="file5">github.com/antoniomralmeida/k2/internal/models/kbattributeobject.go (0.0%)</option>
				
				<option value="file6">github.com/antoniomralmeida/k2/internal/models/kbattributetype.go (100.0%)</option>
				
				<option value="file7">github.com/antoniomralmeida/k2/internal/models/kbclass.go (88.5%)</option>
				
				<option value="file8">github.com/antoniomralmeida/k2/internal/models/kbhistory.go (0.0%)</option>
				
				<option value="file9">github.com/antoniomralmeida/k2/internal/models/kbobject.go (89.6%)</option>
				
				<option value="file10">github.com/antoniomralmeida/k2/internal/models/kbrule.go (37.8%)</option>
				
				<option value="file11">github.com/antoniomralmeida/k2/internal/models/kbsource.go (100.0%)</option>
				
				<option value="file12">github.com/antoniomralmeida/k2/internal/models/kbstack.go (5.0%)</option>
				
				<option value="file13">github.com/antoniomralmeida/k2/internal/models/kbuser.go (0.0%)</option>
				
				<option value="file14">github.com/antoniomralmeida/k2/internal/models/kbworkspace.go (0.0%)</option>
				
				<option value="file15">github.com/antoniomralmeida/k2/internal/models/knowledgebased.go (3.1%)</option>
				
				<option value="file16">github.com/antoniomralmeida/k2/internal/models/literalbin.go (0.0%)</option>
				
				<option value="file17">github.com/antoniomralmeida/k2/internal/models/pair.go (100.0%)</option>
				
				<option value="file18">github.com/antoniomralmeida/k2/internal/models/statment.go (0.0%)</option>
				
				<option value="file19">github.com/antoniomralmeida/k2/internal/models/token.go (91.7%)</option>
				
				<option value="file20">github.com/antoniomralmeida/k2/internal/models/tokentype.go (100.0%)</option>
				
				<option value="file21">github.com/antoniomralmeida/k2/internal/olivia/language/date/date.go (37.5%)</option>
				
				<option value="file22">github.com/antoniomralmeida/k2/internal/olivia/language/date/register.go (100.0%)</option>
				
				<option value="file23">github.com/antoniomralmeida/k2/internal/olivia/language/date/rules.go (76.1%)</option>
				
				<option value="file24">github.com/antoniomralmeida/k2/internal/olivia/locales/locales.go (27.8%)</option>
				
				<option value="file25">github.com/antoniomralmeida/k2/internal/olivia/network/derivative.go (0.0%)</option>
				
				<option value="file26">github.com/antoniomralmeida/k2/internal/olivia/network/math.go (100.0%)</option>
				
				<option value="file27">github.com/antoniomralmeida/k2/internal/olivia/network/matrix.go (95.7%)</option>
				
				<option value="file28">github.com/antoniomralmeida/k2/internal/olivia/network/network.go (0.0%)</option>
				
				<option value="file29">github.com/antoniomralmeida/k2/internal/olivia/user/information.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package models

import (
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
)

type BIN struct {
        TokenType TokenType `json:"tokentype"`
        //pcNextCommand int        `json:"-"`
        LiteralBin LiteralBin `json:"literalbin"`
        Token      string     `json:"token"`
        class      *KBClass   `json:"-"`
        //newAttributes    []KBAttribute        `json:"-"`
        attribute        *KBAttribute         `json:"-"`
        workspace        *KBWorkspace         `json:"-"`
        objects          []*KBObject          `json:"-"` //TODO: Poderia ser dinâmico? Tempo de execução?
        attributeObjects []*KBAttributeObject `json:"-"` //TODO: Poderia ser dinâmico? Tempo de execução?
}

func (b *BIN) GetToken() string <span class="cov8" title="1">{
        return b.Token
}</span>

func (b *BIN) GetTokentype() TokenType <span class="cov8" title="1">{
        return b.TokenType
}</span>

func (b *BIN) CheckLiteralBin() error <span class="cov8" title="1">{
        if b.GetTokentype() == Literal </span><span class="cov8" title="1">{
                var ok bool
                if b.LiteralBin, ok = LiteralBinStr[b.Token]; !ok </span><span class="cov8" title="1">{
                        return lib.LiteralNotFoundError
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (b *BIN) String() string <span class="cov8" title="1">{
        j, err := json.Marshal(*b)
        inits.Log(err, inits.Error)
        return string(j)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package models

import (
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
)

type DataInput struct {
        Name    string          `json:"name"`
        Atype   KBAttributeType `json:"atype"`
        Options []string        `json:"options"`
}

func KBGetDataInput() []*DataInput <span class="cov0" title="0">{
        objs := []KBObject{}
        mgm.Coll(new(KBObject)).SimpleFind(&amp;objs, bson.D{})

        ret := []*DataInput{}
        for i := range objs </span><span class="cov0" title="0">{
                for j := range objs[i].Attributes </span><span class="cov0" title="0">{
                        a := &amp;objs[i].Attributes[j]
                        if a.KbAttribute.isSource(FromUser) &amp;&amp; !a.Validity() </span><span class="cov0" title="0">{
                                di := DataInput{Name: a.KbObject.Name + "." + a.KbAttribute.Name, Atype: a.KbAttribute.AType, Options: a.KbAttribute.Options}
                                ret = append(ret, &amp;di)
                        }</span>
                }
        }
        <span class="cov0" title="0">return ret</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "strings"
        "unicode"

        "github.com/antoniomralmeida/k2/internal/inits"
)

type EBNF struct {
        Rules []*Statement `json:"rules"`
        Base  *Token       `json:"-"`
        last  int          `json:"-"`
}

func EBNFFactory(ebnfFile string) *EBNF <span class="cov8" title="1">{
        _ebnf = new(EBNF)
        _ebnf.grammarLoad(ebnfFile)
        return _ebnf
}</span>
func (e *EBNF) GetBase() *Token <span class="cov8" title="1">{
        return e.Base
}</span>

func (e *EBNF) FindSymbols(str string, both bool) int <span class="cov8" title="1">{
        for i, x := range symbols </span><span class="cov8" title="1">{
                if x.begin == str </span><span class="cov8" title="1">{
                        return i
                }</span>
                <span class="cov8" title="1">if x.end == str &amp;&amp; both </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func (e *EBNF) FindOptions(pt *Token, jumps *[]*Token, level int) map[string]*Token <span class="cov8" title="1">{
        ret := make(map[string]*Token)
        if level &lt; 10 </span><span class="cov8" title="1">{
                if pt.GetTokenType() == Control &amp;&amp; pt.Token == "." </span><span class="cov8" title="1">{
                        if len(*jumps) &gt; 0 </span><span class="cov8" title="1">{
                                pt = (*jumps)[len(*jumps)-1]
                                tmp := (*jumps)[:len(*jumps)-1]
                                jumps = &amp;tmp
                        }</span> else<span class="cov8" title="1"> {
                                ret[pt.Token] = pt
                        }</span>
                }

                <span class="cov8" title="1">for _, x := range pt.Nexts </span><span class="cov8" title="1">{
                        if x.GetTokenType() == Control || x.GetTokenType() == Jump </span><span class="cov8" title="1">{
                                if x.Token == "." </span><span class="cov8" title="1">{
                                        ret[x.Token] = x
                                }</span>
                                <span class="cov8" title="1">for _, k := range e.FindOptions(x, jumps, level+1) </span><span class="cov8" title="1">{
                                        ret[k.Token] = k
                                }</span>
                        } else<span class="cov8" title="1"> if x.GetTokenType() == Reference </span><span class="cov8" title="1">{
                                n := e.Rules[x.Rule_jump].Tokens[0]
                                for _, k := range e.FindOptions(n, jumps, level+1) </span><span class="cov8" title="1">{
                                        ret[k.Token] = k
                                }</span>
                        } else<span class="cov8" title="1"> {
                                ret[x.Token] = x
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret</span>
}

func (e *EBNF) newStatement(str string) *Statement <span class="cov8" title="1">{
        var rule Statement
        rule.Id = len(e.Rules) + 1
        rule.Name = strings.Trim(str, " ")
        e.Rules = append(e.Rules, &amp;rule)
        return &amp;rule
}</span>

func (e *EBNF) newToken(rule *Statement, str string, tokentype TokenType, nexts ...*Token) <span class="cov8" title="1">{
        //Token := Token{Id: len(rule.Tokens) + 1, Token: strings.Trim(str, " "), Rule_id: rule.Id, Tokentype: tokentype}
        e.last++
        Token := Token{Id: e.last, Token: strings.Trim(str, " "), Rule_id: rule.Id, Tokentype: tokentype}
        Token.Nexts = append(Token.Nexts, nexts...)
        rule.Tokens = append(rule.Tokens, &amp;Token)
}</span>

func (e *EBNF) newJump(node *Token, before bool, nexts ...*Token) <span class="cov8" title="1">{
        if before </span><span class="cov8" title="1">{
                node.Nexts = append(nexts, node.Nexts...)
        }</span> else<span class="cov8" title="1"> {
                node.Nexts = append(node.Nexts, nexts...)
        }</span>
}

func (e *EBNF) grammarLoad(ebnfFile string) int <span class="cov8" title="1">{

        file, err := ioutil.ReadFile(ebnfFile)
        if err != nil </span><span class="cov0" title="0">{
                inits.Log("Could not read the file due to this %s error \n"+err.Error(), inits.Fatal)
        }</span>
        <span class="cov8" title="1">ebnf_txt := string(file)
        ebnf_txt = strings.Replace(ebnf_txt, "\r\n", "", -1)
        ebnf_txt = strings.Replace(ebnf_txt, "\\n", "", -1)
        ebnf_txt = strings.Replace(ebnf_txt, "\t", " ", -1)
        for strings.Contains(ebnf_txt, "  ") </span><span class="cov8" title="1">{
                ebnf_txt = strings.Replace(ebnf_txt, "  ", " ", -1)
        }</span>

        <span class="cov8" title="1">rules := strings.Split(ebnf_txt, ".")
        for _, rule := range rules </span><span class="cov8" title="1">{

                var left string
                var right string
                for i := 0; i &lt; len(rule); i++ </span><span class="cov8" title="1">{
                        if rule[i] == '=' </span><span class="cov8" title="1">{
                                left = rule[0:i]
                                right = rule[i:] + "."
                                break</span>
                        }
                }
                <span class="cov8" title="1">if len(left) &gt; 0 </span><span class="cov8" title="1">{
                        var nrule = e.newStatement(left)
                        var inWord = false
                        var inString = false
                        var inRule = false
                        var start = 0
                        for i, c := range right </span><span class="cov8" title="1">{
                                switch </span>{
                                case e.FindSymbols(string(c), true) != -1 || c == ' ' || c == '|':<span class="cov8" title="1">
                                        if inString </span><span class="cov8" title="1">{
                                                if c == '"' </span><span class="cov8" title="1">{
                                                        e.newToken(nrule, right[start:i], Literal)
                                                        inString = false
                                                }</span>
                                        } else<span class="cov8" title="1"> if inWord </span><span class="cov8" title="1">{
                                                var Tokentype = Literal
                                                if inRule </span><span class="cov8" title="1">{
                                                        Tokentype = Reference
                                                }</span>
                                                <span class="cov8" title="1">e.newToken(nrule, right[start:i], Tokentype)
                                                inWord = false
                                                inRule = false</span>
                                        } else<span class="cov8" title="1"> {
                                                if c == '"' </span><span class="cov8" title="1">{
                                                        start = i + 1
                                                        inString = true
                                                }</span>
                                        }
                                        <span class="cov8" title="1">if c != ' ' &amp;&amp; c != '"' &amp;&amp; c != '\'' &amp;&amp; !inString </span><span class="cov8" title="1">{
                                                if c == '|' </span><span class="cov8" title="1">{
                                                        e.newToken(nrule, string(c), Jump)
                                                }</span> else<span class="cov8" title="1"> {
                                                        e.newToken(nrule, string(c), Control)
                                                }</span>
                                        }
                                case unicode.IsLower(c) &amp;&amp; !inWord &amp;&amp; !inString:<span class="cov8" title="1">
                                        start = i
                                        inWord = true</span>
                                case unicode.IsUpper(c) &amp;&amp; !inWord &amp;&amp; !inString:<span class="cov8" title="1">
                                        start = i
                                        inWord = true
                                        inRule = true</span>
                                default:<span class="cov8" title="1"></span>
                                }
                        }
                        <span class="cov8" title="1">e.parsingStatement(nrule)</span>
                }
        }
        <span class="cov8" title="1">errorFatal := false
        for _, r := range e.Rules </span><span class="cov8" title="1">{
                for _, t := range r.Tokens </span><span class="cov8" title="1">{
                        if t.GetTokenType() == Reference </span><span class="cov8" title="1">{
                                t.Rule_jump = e.findRule(t.Token)
                                if t.Rule_jump == -1 </span><span class="cov8" title="1">{
                                        for z := 1; z &lt; t.GetTokenType().Size(); z++ </span><span class="cov8" title="1">{
                                                if t.Token == TokenType(z).String() </span><span class="cov8" title="1">{
                                                        t.Tokentype = TokenType(z)
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if t.GetTokenType() == Reference </span><span class="cov0" title="0">{
                                                errorFatal = true
                                                inits.Log("Reference not found! "+t.Token, inits.Error)
                                        }</span>
                                }

                        }
                        <span class="cov8" title="1">if t.Tokentype == Literal </span><span class="cov8" title="1">{
                                if _, ok := LiteralBinStr[t.Token]; !ok </span><span class="cov0" title="0">{
                                        errorFatal = true
                                        inits.Log("Literal not found! "+t.Token, inits.Error)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if errorFatal </span><span class="cov0" title="0">{
                inits.Log("Fatal error(s) in EBNF parsing!", inits.Fatal)
        }</span>
        <span class="cov8" title="1">e.Base = e.Rules[0].Tokens[0]
        data, err := os.Create(ebnfFile + ".json")
        if err != nil </span><span class="cov0" title="0">{
                inits.Log(err, inits.Error)
        }</span> else<span class="cov8" title="1"> {
                io.Copy(data, strings.NewReader(e.String()))
        }</span>
        <span class="cov8" title="1">data.Close()
        return 1</span>
}

func (e *EBNF) findClose(rule *Statement, symb int, Token string, i int, level int) int <span class="cov8" title="1">{
        for j := i + 1; j &lt; len(rule.Tokens); j++ </span><span class="cov8" title="1">{
                if rule.Tokens[j].GetTokenType() == Control </span><span class="cov8" title="1">{
                        s := symbols[symb]
                        if rule.Tokens[j].Token == s.end &amp;&amp; level == 0 </span><span class="cov8" title="1">{
                                return j
                        }</span> else<span class="cov8" title="1"> if rule.Tokens[j].Token == s.begin </span><span class="cov8" title="1">{
                                return e.findClose(rule, symb, Token, j, level+1)
                        }</span> else<span class="cov8" title="1"> if rule.Tokens[j].Token == s.end </span><span class="cov8" title="1">{
                                return e.findClose(rule, symb, Token, j, level-1)
                        }</span>
                }
        }
        <span class="cov0" title="0">return -1</span>
}

func (e *EBNF) parsingStatement(rule *Statement) <span class="cov8" title="1">{
        var pairs []PAIR
        inits.Log("Parsing ebnf rule "+rule.Name, inits.Info)
        //Finding Pair of Symbols
        for i := 0; i &lt; len(rule.Tokens); i++ </span><span class="cov8" title="1">{
                if rule.Tokens[i].GetTokenType() == Control </span><span class="cov8" title="1">{
                        s := e.FindSymbols(rule.Tokens[i].Token, false)
                        if s != -1 </span><span class="cov8" title="1">{
                                c := e.findClose(rule, s, rule.Tokens[i].Token, i, 0)
                                if c == -1 </span><span class="cov0" title="0">{
                                        msg := fmt.Sprint("Parsing error in Token ", rule.Tokens[i].Token, " #", rule.Tokens[i].Id, s, i)
                                        inits.Log(msg, inits.Fatal)
                                        return
                                }</span>
                                <span class="cov8" title="1">pairs = append(pairs, PAIR{i, c})
                                if rule.Tokens[i].Token == "\"" || rule.Tokens[i].Token == "'" &amp;&amp; c != -1 </span><span class="cov0" title="0">{
                                        i = c + 1
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">for i := 0; i &lt; len(rule.Tokens)-1; i++ </span><span class="cov8" title="1">{
                var p = findPair(pairs, i)
                if rule.Tokens[i].GetTokenType() != Jump </span><span class="cov8" title="1">{
                        e.newJump(rule.Tokens[i], false, rule.Tokens[i+1])
                }</span> else<span class="cov8" title="1"> {
                        e.newJump(rule.Tokens[i], false, rule.Tokens[pairs[p].end])
                        e.newJump(rule.Tokens[pairs[p].begin], false, rule.Tokens[i+1])
                }</span>
                <span class="cov8" title="1">if rule.Tokens[i].Token == "{" </span><span class="cov8" title="1">{
                        e.newJump(rule.Tokens[pairs[p].begin], true, rule.Tokens[pairs[p].end])
                        e.newJump(rule.Tokens[pairs[p].end], false, rule.Tokens[pairs[p].begin])
                }</span>
                <span class="cov8" title="1">if rule.Tokens[i].Token == "[" </span><span class="cov8" title="1">{
                        e.newJump(rule.Tokens[pairs[p].begin], false, rule.Tokens[pairs[p].end])
                }</span>
        }
}

func (e *EBNF) findRule(key string) int <span class="cov8" title="1">{
        for i, r := range e.Rules </span><span class="cov8" title="1">{
                if r.Name == key </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func (e *EBNF) String() string <span class="cov8" title="1">{
        ret, err := json.MarshalIndent(e.Rules, "", "    ")
        inits.Log(err, inits.Error)
        return string(ret)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBAlert struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Message          string               `bson:"message"`
        User             primitive.ObjectID   `bson:"user"`
        Views            []primitive.ObjectID `bson:"views"`
}

func getLastAlerts(user primitive.ObjectID) ([]KBAlert, error) <span class="cov0" title="0">{
        alerts := []KBAlert{}
        opts := options.Find().SetSort(bson.D{{"create_at", -1}}).SetLimit(5)

        err := mgm.Coll(new(KBAlert)).SimpleFind(alerts, bson.M{"$or": bson.A{
                bson.M{"user": user},
                bson.M{"user": ""},
        }}, opts)
        return alerts, err
}</span>

func NewAlert(msg string, email string) error <span class="cov0" title="0">{
        alert := new(KBAlert)
        alert.Message = msg
        if email != "" </span><span class="cov0" title="0">{
                user := new(KBUser)
                err := user.FindOne(bson.D{{Key: "email", Value: email}})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">alert.User = user.ID</span>
        }
        <span class="cov0" title="0">err := alert.Persist()
        return err</span>
}

func (obj *KBAlert) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (obj *KBAlert) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "github.com/asaskevich/govalidator"
        "go.mongodb.org/mongo-driver/bson/primitive"
)

type KBAttribute struct {
        ID               primitive.ObjectID `bson:"id"`
        Name             string             `bson:"name" valid:"length(2|50),required"`
        AType            KBAttributeType    `bson:"atype" valid:"required"`
        KeepHistory      int                `bson:"keephistory" valid:range(0|5000)`             //Numero de historico a manter, 0- manter todos
        ValidityInterval int64              `bson:"validityinterval" valid:range(0|86400000000)` //validade do ultimo valor em microssegudos, 0- sempre
        SimulationID     KBSimulation       `bson:"simulation,omitempty" json:"-"`
        Simulation       string             `bson:"-" json:"simulation"`
        SourcesID        []KBSource         `bson:"sources" valid:"required"`
        Options          []string           `bson:"options,omitempty"`
        Sources          []string           `bson:"-" json:"sources"`
        antecedentRules  []*KBRule          `bson:"-"`
        consequentRules  []*KBRule          `bson:"-"`
}

func (obj *KBAttribute) validate() (bool, error) <span class="cov8" title="1">{
        return govalidator.ValidateStruct(obj)
}</span>

func (a *KBAttribute) addAntecedentRules(r *KBRule) <span class="cov0" title="0">{
        found := false
        for i := range a.antecedentRules </span><span class="cov0" title="0">{
                if a.antecedentRules[i] == r </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                a.antecedentRules = append(a.antecedentRules, r)
        }</span>
}

func (a *KBAttribute) addConsequentRules(r *KBRule) <span class="cov0" title="0">{
        found := false
        for i := range a.consequentRules </span><span class="cov0" title="0">{
                if a.consequentRules[i] == r </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                a.consequentRules = append(a.consequentRules, r)
        }</span>
}

func (a *KBAttribute) isSource(s KBSource) bool <span class="cov0" title="0">{
        for i := range a.SourcesID </span><span class="cov0" title="0">{
                if a.SourcesID[i] == s </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/antoniomralmeida/k2/internal/fuzzy"
        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        mqtt "github.com/eclipse/paho.mqtt.golang"

        "github.com/kamva/mgm/v3"
        "github.com/montanaflynn/stats"
        p "github.com/rafaeljesus/parallel-fn"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "gonum.org/v1/gonum/stat"
)

const (
        topinIn  = "/in"
        topinOut = "/out"
)

type MTQQValue struct {
        TopicPath string `json:"topicpath"`
        Value     any    `json:"value"`
}

type KBAttributeObject struct {
        ID          primitive.ObjectID ` bson:"id"`
        Attribute   primitive.ObjectID `bson:"attribute_id"  json:"AttributeId"`
        KbObject    *KBObject          `bson:"-" json:"-" valid:"-"`
        KbHistory   *KBHistory         `bson:"-" json:"History"`
        KbAttribute *KBAttribute       `bson:"-"  json:"Attrinute"`
}

func KBAttributeObjectFactory(obj *KBObject, attr *KBAttribute) *KBAttributeObject <span class="cov0" title="0">{
        a := KBAttributeObject{Attribute: attr.ID}
        obj.Attributes = append(obj.Attributes, a)
        err := obj.Persist()
        if err == nil </span><span class="cov0" title="0">{
                return &amp;a
        }</span> else<span class="cov0" title="0"> {
                inits.Log(err, inits.Fatal)
                return nil
        }</span>
}

func (ao *KBAttributeObject) Validity() bool <span class="cov0" title="0">{
        if ao.KbHistory != nil </span><span class="cov0" title="0">{
                if ao.KbAttribute.ValidityInterval != 0 </span><span class="cov0" title="0">{
                        diff := time.Now().Sub(time.Unix(0, ao.KbHistory.When))
                        if diff.Milliseconds() &gt; ao.KbAttribute.ValidityInterval </span><span class="cov0" title="0">{
                                ao.KbHistory = nil
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (ao *KBAttributeObject) ValueString() (string, float64, KBAttributeType) <span class="cov0" title="0">{
        v, t, tp := ao.Value()
        value := fmt.Sprint(v)
        if tp == KBString || tp == KBList </span><span class="cov0" title="0">{
                value = "\"" + value + "\""
        }</span>
        <span class="cov0" title="0">return value, t, tp</span>
}
func (ao *KBAttributeObject) Value() (any, float64, KBAttributeType) <span class="cov0" title="0">{
        ao.KbHistory.FindLast(bson.D{{Key: "attribute_id", Value: ao.Attribute}})
        if ao.Validity() </span><span class="cov0" title="0">{
                if KBDate == ao.KbAttribute.AType </span><span class="cov0" title="0">{
                        i, _ := strconv.ParseInt(fmt.Sprintf("%v", ao.KbHistory.Value), 10, 64)
                        return time.Unix(0, i), ao.KbHistory.Trust, ao.KbAttribute.AType
                }</span>
                <span class="cov0" title="0">return ao.KbHistory.Value, ao.KbHistory.Trust, ao.KbAttribute.AType</span>
        } else<span class="cov0" title="0"> {
                timeout := time.After(1 * time.Second) // real-time search
                fn1 := func() error </span><span class="cov0" title="0">{
                        for _, r := range ao.KbAttribute.consequentRules </span><span class="cov0" title="0">{ //backward chaining
                                r.Run()
                                if ao.KbHistory != nil </span><span class="cov0" title="0">{ //when find a value (stop)
                                        return nil
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">fn2 := func() error </span><span class="cov0" title="0">{
                        if ao.KbAttribute.isSource(Simulation) </span><span class="cov0" title="0">{
                                switch ao.KbAttribute.SimulationID </span>{
                                case MonteCarlo:<span class="cov0" title="0">
                                        ao.MonteCarlo()</span>
                                case LinearRegression:<span class="cov0" title="0">
                                        ao.LinearRegression()</span>
                                case NormalDistribution:<span class="cov0" title="0">
                                        ao.NormalDistribution()</span>
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">fn3 := func() error </span><span class="cov0" title="0">{
                        if ao.KbAttribute.isSource(IOT) </span><span class="cov0" title="0">{
                                ao.IOTParsing()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                //TODO: testar a execução paralela
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        select </span>{
                        case e := &lt;-p.Run(fn1, fn2, fn3):<span class="cov0" title="0">
                                inits.Log(e, inits.Error)
                                return nil, 0, NotDefined</span>
                        case &lt;-timeout:<span class="cov0" title="0">
                                if ao.KbHistory != nil </span><span class="cov0" title="0">{
                                        return ao.KbHistory.Value, ao.KbHistory.Trust, ao.KbAttribute.AType
                                }</span>
                        }
                }
        }

}
func (attr *KBAttributeObject) getFullName() string <span class="cov0" title="0">{
        return attr.KbObject.Name + "." + attr.KbAttribute.Name
}</span>

func (attr *KBAttributeObject) String() string <span class="cov0" title="0">{
        j, err := json.MarshalIndent(*attr, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (attr *KBAttributeObject) GetMtqqTopic(direction string) string <span class="cov0" title="0">{
        return strings.ToLower(attr.KbObject.Name) + "/" + strings.ToLower(attr.KbAttribute.Name) + direction
}</span>

func (attr *KBAttributeObject) SetValue(value any, source KBSource, trust float64) *KBHistory <span class="cov0" title="0">{
        if attr == nil </span><span class="cov0" title="0">{
                inits.Log("Invalid attribute!", inits.Error)
                return nil
        }</span>
        <span class="cov0" title="0">if !attr.KbAttribute.isSource(source) &amp;&amp; source != Inference </span><span class="cov0" title="0">{
                inits.Log("Invalid attribute source!", inits.Error)
                return nil
        }</span>
        //if IOT is Source, pub MTQQ msg in topic of atrributte of object
        <span class="cov0" title="0">if attr.KbAttribute.isSource(IOT) </span><span class="cov0" title="0">{
                mtqqmsg := MTQQValue{Value: value, TopicPath: attr.GetMtqqTopic(topinOut)}
                json, _ := json.Marshal(mtqqmsg)
                inits.Publish(mtqqmsg.TopicPath, string(json))
        }</span>

        <span class="cov0" title="0">if reflect.TypeOf(value).String() == "string" </span><span class="cov0" title="0">{
                str := fmt.Sprintf("%v", value)
                switch attr.KbAttribute.AType </span>{
                case KBNumber:<span class="cov0" title="0">
                        value, _ = strconv.ParseFloat(str, 64)</span>
                case KBDate:<span class="cov0" title="0">
                        t, err := time.Parse(lib.YYYYMMDD, str)
                        if err == nil </span><span class="cov0" title="0">{
                                value = t.UnixNano()
                        }</span> else<span class="cov0" title="0"> {
                                inits.Log(err, inits.Error)
                                return nil
                        }</span>
                }
        }
        <span class="cov0" title="0">h := KBHistory{Attribute: attr.ID, When: time.Now().UnixNano(), Value: value, Source: source, Trust: trust}
        inits.Log(h.Persist(), inits.Fatal)
        attr.KbHistory = &amp;h
        KBAddStack(attr.KbAttribute.antecedentRules) //  forward chaining

        if attr.KbAttribute.KeepHistory != 0 </span><span class="cov0" title="0">{
                go h.ClearingHistory(attr.KbAttribute.KeepHistory)
        }</span>
        <span class="cov0" title="0">return &amp;h</span>
}

func (attr *KBAttributeObject) LinearRegression() error <span class="cov0" title="0">{
        type PipeValue struct {
                value float64
                when  int64
                trust float64
        }
        inits.Log("LinearRegression...", inits.Info)
        collection := mgm.Coll(new(KBHistory))
        if attr.KbAttribute.AType == KBNumber </span><span class="cov0" title="0">{
                matchStage := bson.D{{Key: "attribute_id", Value: attr.ID}}
                groupStage := bson.D{{Key: "$project", Value: bson.D{{Key: "_id", Value: 0}, {Key: "value", Value: 1}, {Key: "when", Value: 1}, {Key: "trust", Value: 1}}}}
                ret, err := collection.Aggregate(mgm.Ctx(), mongo.Pipeline{matchStage, groupStage}) // Aggregate(ctx,
                inits.Log(err, inits.Error)
                var resp []PipeValue
                err = ret.All(mgm.Ctx(), &amp;resp)
                inits.Log(err, inits.Error)
                if len(resp) &lt;= 2 </span><span class="cov0" title="0">{
                        inits.Log("cannot do linear regression with | C|&lt;=2", inits.Info)
                        return nil
                }</span>
                <span class="cov0" title="0">X := make([]float64, len(resp))
                Y := make([]float64, len(resp))
                T := make([]float64, len(resp))
                for i := range resp </span><span class="cov0" title="0">{
                        X[i] = float64(resp[i].when)
                        Y[i] = resp[i].value
                        T[i] = resp[i].trust
                }</span>
                <span class="cov0" title="0">trust := stat.Mean(T, nil) / 100.0
                alpha, beta := stat.LinearRegression(X, Y, nil, false)
                r2 := stat.RSquared(X, Y, nil, alpha, beta)
                xn := float64(time.Now().UnixNano())
                fx := alpha + xn*beta
                attr.SetValue(fx, KBSource(Simulation), r2*trust*100.0)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (attr *KBAttributeObject) MonteCarlo() error <span class="cov0" title="0">{
        inits.Log("MonteCarlo...", inits.Info)
        if attr.KbAttribute.AType == KBNumber </span><span class="cov0" title="0">{
                collection := mgm.Coll(new(KBHistory))
                matchStage := bson.D{{Key: "attribute_id", Value: attr.ID}}
                groupStage := bson.D{{Key: "$group", Value: bson.D{{Key: "_id", Value: "$attribute_id"},
                        {Key: "avg", Value: bson.D{{Key: "$avg", Value: "$value"}}},
                        {Key: "stdDev", Value: bson.D{{Key: "$stdDevPop", Value: "$value"}}},
                        {Key: "trust", Value: bson.D{{Key: "$avg", Value: "$trust"}}},
                }}}
                ret, err := collection.Aggregate(mgm.Ctx(), mongo.Pipeline{matchStage, groupStage}) // Aggregate(ctx,
                inits.Log(err, inits.Error)
                var results []Pipe
                err = ret.All(mgm.Ctx(), &amp;results)
                inits.Log(err, inits.Error)

                resp := []Pipe{}
                err = ret.All(mgm.Ctx(), &amp;resp)
                inits.Log(err, inits.Error)

                avg := resp[0].avg
                stdDev := resp[0].stdDev
                trust := resp[0].trust
                r := stats.NormPpfRvs(avg, stdDev, 1)[0]
                a := stats.NormPpf(r, avg, stdDev) * (trust / 100.0)
                attr.SetValue(r, KBSource(Simulation), a*100)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (attr *KBAttributeObject) NormalDistribution() error <span class="cov0" title="0">{

        inits.Log("NormalDistribution...", inits.Info)
        if attr.KbAttribute.AType == KBNumber </span><span class="cov0" title="0">{
                collection := mgm.Coll(new(KBHistory))

                matchStage := bson.D{{Key: "attribute_id", Value: attr.ID}}
                groupStage := bson.D{{Key: "$group", Value: bson.D{{Key: "_id", Value: "$attribute_id"},
                        {Key: "avg", Value: bson.D{{Key: "$avg", Value: "$value"}}},
                        {Key: "stdDev", Value: bson.D{{Key: "$stdDevPop", Value: "$value"}}},
                        {Key: "trust", Value: bson.D{{Key: "$avg", Value: "$trust"}}},
                }}}
                ret, err := collection.Aggregate(mgm.Ctx(), mongo.Pipeline{matchStage, groupStage}) // Aggregate(ctx,
                inits.Log(err, inits.Error)
                var results []Pipe
                err = ret.All(mgm.Ctx(), &amp;results)
                inits.Log(err, inits.Error)

                resp := []Pipe{}
                err = ret.All(mgm.Ctx(), &amp;resp)
                inits.Log(err, inits.Error)
                avg, _ := strconv.ParseFloat(fmt.Sprintf("%v", resp[0].avg), 64)
                stdDev, _ := strconv.ParseFloat(fmt.Sprintf("%v", resp[0].stdDev), 64)
                trust, _ := strconv.ParseFloat(fmt.Sprintf("%v", resp[0].trust), 32)
                r := stats.NormPpfRvs(avg, stdDev, 1)[0]
                a := stats.NormPpf(r, avg, stdDev) * (trust / 100.0)
                attr.SetValue(r, KBSource(Simulation), a*100)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (attr *KBAttributeObject) IOTParsing() error <span class="cov0" title="0">{
        inits.Log("IOTParsing...", inits.Info)
        var msgPubHandler mqtt.MessageHandler = func(client mqtt.Client, msg mqtt.Message) </span><span class="cov0" title="0">{
                value := new(MTQQValue)
                err := json.Unmarshal(msg.Payload(), value)
                inits.Log(err, inits.Error)
                if err == nil </span><span class="cov0" title="0">{
                        attr.SetValue(value.Value, IOT, fuzzy.TrustIOT)
                }</span>
        }
        <span class="cov0" title="0">inits.Subscribe(attr.GetMtqqTopic(topinIn), msgPubHandler)
        return nil</span>
}

func (a *KBAttributeObject) InObjects(objs []*KBObject) bool <span class="cov0" title="0">{
        for i := range objs </span><span class="cov0" title="0">{
                if objs[i] == a.KbObject </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func FindAttributeObject(obj *KBObject, attr string) *KBAttributeObject <span class="cov0" title="0">{
        for i := range obj.Attributes </span><span class="cov0" title="0">{
                if obj.Attributes[i].KbAttribute.Name == attr </span><span class="cov0" title="0">{
                        return &amp;obj.Attributes[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func FindAttributeObjectByName(key string) *KBAttributeObject <span class="cov0" title="0">{
        keys := strings.Split(key, ".")
        ao := new(KBObject)
        r := mgm.Coll(ao).FindOne(mgm.Ctx(), bson.D{{"name", keys[0]}, {"attribute.name", key[1]}})
        r.Decode(ao)
        return &amp;ao.Attributes[0]
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import "strings"

type KBAttributeType int

const (
        NotDefined KBAttributeType = iota
        KBString
        KBDate
        KBNumber
        KBList
)

func KBattributeTypeStr(str string) KBAttributeType <span class="cov8" title="1">{
        return attributeTypeMap[strings.ToLower(str)]
}</span>

var attributeTypeMap = map[string]KBAttributeType{
        "string": KBString,
        "date":   KBDate,
        "number": KBNumber,
        "list":   KBList,
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package models

import (
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        "github.com/asaskevich/govalidator"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBClass struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Name             string             `bson:"name" valid:"length(5|50),required"`
        Icon             string             `bson:"icon"`
        ParentID         primitive.ObjectID `bson:"parent_id,omitempty"`
        Parent           string             `bson:"-" json:"parent"`
        Attributes       []KBAttribute      `bson:"attributes"`
        ParentClass      *KBClass           `bson:"-"`
}

func (obj *KBClass) ValidateIndex() error <span class="cov8" title="1">{
        cur, err := mgm.Coll(obj).Indexes().List(mgm.Ctx())
        inits.Log(err, inits.Error)
        var result []bson.M
        err = cur.All(mgm.Ctx(), &amp;result)
        if len(result) == 1 </span><span class="cov0" title="0">{
                inits.CreateUniqueIndex(mgm.Coll(obj), "name")
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (obj *KBClass) validate() (bool, error) <span class="cov8" title="1">{
        return govalidator.ValidateStruct(obj)
}</span>

func KBClassFactoryParent(name, icon string, parentClass *KBClass) (class *KBClass, err error) <span class="cov8" title="1">{
        if parentClass != nil </span><span class="cov8" title="1">{
                class = &amp;KBClass{Name: name, Icon: icon, ParentClass: parentClass, ParentID: parentClass.ID}
        }</span> else<span class="cov8" title="1"> {
                class = &amp;KBClass{Name: name, Icon: icon}
        }</span>
        <span class="cov8" title="1">ok, err := class.validate()
        inits.Log(err, inits.Error)
        if !ok </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = class.Persist()
        if mongo.IsDuplicateKeyError(err) </span><span class="cov0" title="0">{
                inits.Log(err, inits.Error)
        }</span> else<span class="cov8" title="1"> {
                inits.Log(err, inits.Fatal)
        }</span>
        <span class="cov8" title="1">return class, err</span>
}

func KBClassFactory(name, icon, parent string) (class *KBClass, err error) <span class="cov8" title="1">{
        var parentClass *KBClass
        if parent != "" </span><span class="cov8" title="1">{
                parentClass = FindClassByName(parent, true)
                if parentClass == nil </span><span class="cov8" title="1">{
                        inits.Log(lib.ClassNotFoundError, inits.Info)
                        return nil, lib.ClassNotFoundError
                }</span>
        } else<span class="cov8" title="1"> {
                parentClass = nil
        }</span>
        <span class="cov8" title="1">return KBClassFactoryParent(name, icon, parentClass)</span>
}

func (obj *KBClass) AlterClassAddAttribute(name, atype, simulation string, options, sources []string, keephistory int, valitade int64) (attr *KBAttribute, err error) <span class="cov8" title="1">{
        a := KBAttribute{ID: primitive.NewObjectID(),
                Name:             name,
                AType:            KBattributeTypeStr(atype),
                Options:          options,
                Sources:          sources,
                SourcesID:        ToKBSources(sources),
                KeepHistory:      keephistory,
                ValidityInterval: valitade,
                Simulation:       simulation,
                SimulationID:     KBSimulationStr[simulation]}
        ok, err := a.validate()
        inits.Log(err, inits.Error)
        if ok </span><span class="cov8" title="1">{
                obj.Attributes = append(obj.Attributes, a)
                err = obj.Persist()
                if err == nil </span><span class="cov8" title="1">{
                        return &amp;a, nil
                }</span>
                <span class="cov0" title="0">inits.Log(err, inits.Error)</span>
        }
        <span class="cov8" title="1">return nil, err</span>
}

func (obj *KBClass) Persist() error <span class="cov8" title="1">{
        return inits.Persist(obj)
}</span>

func (obj *KBClass) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov8" title="1">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (class *KBClass) FindOne(p bson.M) error <span class="cov8" title="1">{
        ret := mgm.Coll(class).FindOne(mgm.Ctx(), p)
        if ret.Err() == nil </span><span class="cov8" title="1">{
                ret.Decode(class)
                return nil
        }</span> else<span class="cov8" title="1"> {
                return lib.ClassNotFoundError
        }</span>
}

func (class *KBClass) Delete() error <span class="cov8" title="1">{
        res := mgm.Coll(class).FindOne(mgm.Ctx(), bson.D{{"parente", class.ID}})
        if res.Err() == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                res = mgm.Coll(new(KBObject)).FindOne(mgm.Ctx(), bson.D{{"class", class.ID}})
                if res.Err() == mongo.ErrNoDocuments </span><span class="cov8" title="1">{
                        err := mgm.Coll(class).Delete(class)
                        if err == nil </span><span class="cov8" title="1">{
                                restartKB()
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }
        }
        <span class="cov0" title="0">return mongo.ErrMultipleIndexDrop</span>
}

func (class *KBClass) String() string <span class="cov8" title="1">{
        j, err := json.MarshalIndent(*class, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (c *KBClass) FindAttributes() []*KBAttribute <span class="cov8" title="1">{
        var ret []*KBAttribute
        if c.ParentClass != nil </span><span class="cov8" title="1">{
                ret = append(ret, c.ParentClass.FindAttributes()...)
        }</span>
        <span class="cov8" title="1">for i := range c.Attributes </span><span class="cov8" title="1">{
                ret = append(ret, &amp;c.Attributes[i])
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func (c *KBClass) FindAttribute(name string) *KBAttribute <span class="cov8" title="1">{
        attrs := c.FindAttributes()
        for i, x := range attrs </span><span class="cov8" title="1">{
                if x.Name == name </span><span class="cov8" title="1">{
                        return attrs[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func FindClassByName(nm string, mandatory bool) *KBClass <span class="cov8" title="1">{
        ret := new(KBClass)
        err := ret.FindOne(bson.M{"name": nm})
        if err != nil &amp;&amp; mandatory </span><span class="cov8" title="1">{
                inits.Log(err, inits.Error)
                return nil
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return ret
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func FindAllClasses(sort string) (class *[]KBClass, err error) <span class="cov8" title="1">{
        class = new([]KBClass)
        cursor, err := mgm.Coll(new(KBClass)).Find(mgm.Ctx(), bson.M{}, options.Find().SetSort(bson.D{{Key: sort, Value: 1}}))
        inits.Log(err, inits.Fatal)
        if err == nil </span><span class="cov8" title="1">{
                err = cursor.All(mgm.Ctx(), class)
        }</span>
        <span class="cov8" title="1">return</span>
}

func KBClassCopy(name string, copy *KBClass) (*KBClass, error) <span class="cov8" title="1">{
        if copy == nil </span><span class="cov0" title="0">{
                inits.Log(lib.InvalidClassError, inits.Error)
                return nil, lib.InvalidClassError
        }</span>
        <span class="cov8" title="1">class := *copy
        class.ID = primitive.NilObjectID
        class.Name = name
        for i := range class.Attributes </span><span class="cov8" title="1">{
                class.Attributes[i].ID = primitive.NewObjectID()
        }</span>
        <span class="cov8" title="1">err := class.Persist()
        if err == nil </span><span class="cov8" title="1">{
                _classes = append(_classes, class)
                return &amp;class, nil
        }</span> else<span class="cov0" title="0"> {
                inits.Log(err, inits.Error)
                return nil, err
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBHistory struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Attribute        primitive.ObjectID `bson:"attribute_id"`
        When             int64              `bson:"when"`
        Value            any                `bson:"value"`
        Trust            float64            `bson:"trust,omitempty"`
        Source           KBSource           `bson:"source"`
}

func (obj *KBHistory) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KBHistory) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (h *KBHistory) ClearingHistory(history int) error <span class="cov0" title="0">{

        type PipeCount struct {
                Id    primitive.ObjectID `json:"_id"`
                Count int                `json:"count"`
        }

        Id := h.Attribute
        collection := mgm.Coll(h)
        for </span><span class="cov0" title="0">{
                matchStage := bson.D{{Key: "attribute_id", Value: Id}}
                groupStage := bson.D{{Key: "$group", Value: bson.D{{Key: "_id", Value: "$attribute_id"}, {Key: "count", Value: bson.D{{Key: "$sum", Value: 1}}}}}}
                ret, err := collection.Aggregate(mgm.Ctx(), mongo.Pipeline{matchStage, groupStage})
                inits.Log(err, inits.Error)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">results := []PipeCount{}
                err = ret.All(mgm.Ctx(), &amp;results)
                inits.Log(err, inits.Error)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if results[0].Count &lt;= history </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">todel := KBHistory{}
                collection.FindOne(mgm.Ctx(), bson.D{{Key: "attribute_id", Value: Id}}, options.FindOne().SetSort(bson.D{{Key: "when", Value: 1}})).Decode(&amp;todel)
                if !todel.ID.IsZero() </span><span class="cov0" title="0">{
                        collection.DeleteOne(mgm.Ctx(), bson.D{{Key: "_id", Value: todel.ID}})
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }
}

func (h *KBHistory) FindLast(filter bson.D) error <span class="cov0" title="0">{
        collection := mgm.Coll(h)
        ret := collection.FindOne(mgm.Ctx(), filter, options.FindOne().SetSort(bson.D{{Key: "when", Value: -1}}))
        if ret != nil </span><span class="cov0" title="0">{
                ret.Decode(h)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *KBHistory) String() string <span class="cov0" title="0">{
        j, err := json.MarshalIndent(*h, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import (
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        "github.com/asaskevich/govalidator"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBObject struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Name             string              `bson:"name" valid:"length(5|50),required"`
        Class            primitive.ObjectID  `bson:"class_id"`
        Attributes       []KBAttributeObject `bson:"attributes"`
        ClassPtr         *KBClass            `bson:"-"`
        Parsed           bool                `bson:"-"`
}

func (obj *KBObject) validate() (bool, error) <span class="cov8" title="1">{
        return govalidator.ValidateStruct(obj)
}</span>

func ObjectFactory(name, className string) (*KBObject, error) <span class="cov8" title="1">{
        class := FindClassByName(className, true)
        if class == nil </span><span class="cov8" title="1">{
                inits.Log(lib.ClassNotFoundError, inits.Error)
                return nil, lib.ClassNotFoundError
        }</span>
        <span class="cov8" title="1">return ObjectFactoryByClass(name, class)</span>
}

func (obj *KBObject) ValidateIndex() error <span class="cov8" title="1">{
        cur, err := mgm.Coll(obj).Indexes().List(mgm.Ctx())
        inits.Log(err, inits.Error)
        var result []bson.M
        err = cur.All(mgm.Ctx(), &amp;result)
        if len(result) == 1 </span><span class="cov0" title="0">{
                inits.CreateUniqueIndex(mgm.Coll(obj), "name")
        }</span>
        <span class="cov8" title="1">return err</span>
}

func FindObjectByName(name string) (ret *KBObject) <span class="cov8" title="1">{
        ret = nil
        cur := mgm.Coll(ret).FindOne(mgm.Ctx(), bson.D{{"name", name}})
        inits.Log(cur.Err(), inits.Error)
        if cur.Err() == nil </span><span class="cov8" title="1">{
                ret = new(KBObject)
                cur.Decode(ret)
        }</span>
        <span class="cov8" title="1">return</span>
}

func ObjectFactoryByClass(name string, class *KBClass) (*KBObject, error) <span class="cov8" title="1">{
        obj := KBObject{Name: name, Class: class.ID, ClassPtr: class}
        for _, x := range class.FindAttributes() </span><span class="cov8" title="1">{
                n := KBAttributeObject{ID: primitive.NewObjectID(), Attribute: x.ID, KbAttribute: x, KbObject: &amp;obj}
                obj.Attributes = append(obj.Attributes, n)
        }</span>
        <span class="cov8" title="1">ok, err := obj.validate()
        if !ok </span><span class="cov0" title="0">{
                inits.Log(err, inits.Error)
                return nil, err
        }</span>
        <span class="cov8" title="1">err = obj.Persist()
        if mongo.IsDuplicateKeyError(err) </span><span class="cov8" title="1">{
                inits.Log(err, inits.Error)
        }</span> else<span class="cov8" title="1"> {
                inits.Log(err, inits.Fatal)
        }</span>
        <span class="cov8" title="1">return &amp;obj, err</span>
}

func (obj *KBObject) Persist() error <span class="cov8" title="1">{
        return inits.Persist(obj)
}</span>

func (obj *KBObject) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (o *KBObject) String() string <span class="cov8" title="1">{
        j, err := json.MarshalIndent(*o, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (o *KBObject) Delete() error <span class="cov8" title="1">{
        mgm.Coll(o).Delete(o)
        if kb_current != nil </span><span class="cov0" title="0">{
                // Restart KB
                kb_current.RestartFlag = true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func FindAllObjects(filter bson.M, sort string) (objs []KBObject, err error) <span class="cov8" title="1">{
        objs = []KBObject{}
        cursor, err := mgm.Coll(new(KBObject)).Find(mgm.Ctx(), filter, options.Find().SetSort(bson.D{{Key: sort, Value: 1}}))
        inits.Log(err, inits.Fatal)
        if err == nil </span><span class="cov8" title="1">{
                err = cursor.All(mgm.Ctx(), &amp;objs)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package models

import (
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"
        "unicode"

        "github.com/PaesslerAG/gval"
        "github.com/asaskevich/govalidator"
        "github.com/kamva/mgm/v3"

        "github.com/antoniomralmeida/k2/internal/fuzzy"
        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        "github.com/antoniomralmeida/k2/pkg/cartesian"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBRule struct {
        mgm.DefaultModel  `json:",inline" bson:",inline"`
        Name              string     `bson:"name" valid:"length(5|50),required"`
        Statement         string     `bson:"statement" valid:"required"`
        Priority          byte       `bson:"priority"` //0..100
        ExecutionInterval int        `bson:"interval"`
        Lastexecution     time.Time  `bson:"lastexecution"`
        consequent        int        `bson:"-"`
        inRun             bool       `bson:"-"`
        bkclasses         []*KBClass `bson:"-"`
        bin               []*BIN     `bson:"-"`
}

func (obj *KBRule) ValidateIndex() error <span class="cov8" title="1">{
        cur, err := mgm.Coll(obj).Indexes().List(mgm.Ctx())
        inits.Log(err, inits.Error)
        var result []bson.M
        err = cur.All(mgm.Ctx(), &amp;result)
        if len(result) == 1 </span><span class="cov0" title="0">{
                inits.CreateUniqueIndex(mgm.Coll(obj), "name")
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (obj *KBRule) validate() (bool, error) <span class="cov8" title="1">{
        return govalidator.ValidateStruct(obj)
}</span>

func RuleFactory(name, statement string, priority byte, interval int) (*KBRule, error) <span class="cov8" title="1">{

        bin, err, detail := parsingRule(statement)
        if err != nil </span><span class="cov8" title="1">{
                inits.Log(fmt.Sprintf("%v %v", err, detail.String()), inits.Error)
                return nil, err
        }</span>
        <span class="cov8" title="1">rule := KBRule{Name: name, Statement: statement, Priority: priority, ExecutionInterval: interval}

        ok, err := rule.validate()
        inits.Log(err, inits.Error)
        if !ok </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = linkerRule(&amp;rule, bin)
        if err != nil </span><span class="cov0" title="0">{
                inits.Log(err, inits.Error)
                return nil, err
        }</span>
        <span class="cov8" title="1">err = rule.Persist()
        if mongo.IsDuplicateKeyError(err) </span><span class="cov0" title="0">{
                inits.Log(err, inits.Error)
        }</span> else<span class="cov8" title="1"> {
                inits.Log(err, inits.Fatal)
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return &amp;rule, nil
        }</span> else<span class="cov0" title="0"> {
                return nil, err
        }</span>
}

func (r *KBRule) String() string <span class="cov8" title="1">{
        j, err := json.MarshalIndent(*r, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (obj *KBRule) Persist() error <span class="cov8" title="1">{
        return inits.Persist(obj)
}</span>
func FindRuleByName(name string) (ret *KBRule) <span class="cov8" title="1">{
        ret = nil
        cur := mgm.Coll(ret).FindOne(mgm.Ctx(), bson.D{{"name", name}})
        inits.Log(cur.Err(), inits.Error)
        if cur.Err() == nil </span><span class="cov8" title="1">{
                ret = new(KBRule)
                cur.Decode(ret)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (obj *KBRule) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov8" title="1">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (r *KBRule) addClass(c *KBClass) <span class="cov8" title="1">{
        found := false
        for i := range r.bkclasses </span><span class="cov0" title="0">{
                if r.bkclasses[i] == c </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                r.bkclasses = append(r.bkclasses, c)
        }</span>
}

func (r *KBRule) GetBins() []*BIN <span class="cov0" title="0">{
        return r.bin
}</span>

func FindAllRules(sort string, rules *[]KBRule) error <span class="cov8" title="1">{
        collection := mgm.Coll(new(KBRule))
        cursor, err := collection.Find(mgm.Ctx(), bson.M{}, options.Find().SetSort(bson.D{{Key: sort, Value: 1}}))
        inits.Log(err, inits.Fatal)
        err = cursor.All(mgm.Ctx(), rules)
        return err
}</span>

func tokeningStatement(cmd string) []string <span class="cov8" title="1">{
        cmd = strings.Replace(cmd, "\r\n", "", -1)
        cmd = strings.Replace(cmd, "\\n", "", -1)
        cmd = strings.Replace(cmd, "\t", " ", -1)
        for strings.Contains(cmd, "  ") </span><span class="cov0" title="0">{
                cmd = strings.Replace(cmd, "  ", " ", -1)
        }</span>
        <span class="cov8" title="1">inits.Log("Parsing Statement: "+cmd, inits.Info)
        var inWord = false
        var inString = false
        var inNumber = false
        var start = 0
        var tokens []string
        const endline = '春'
        cmd = cmd + string(endline)
        for i, c := range cmd </span><span class="cov8" title="1">{
                switch </span>{
                case c == '春' || c == ' ' || _ebnf.FindSymbols(string(c), true) != -1:<span class="cov8" title="1">
                        if inNumber &amp;&amp; c != '.' </span><span class="cov8" title="1">{
                                tokens = append(tokens, cmd[start:i])
                                inNumber = false
                        }</span> else<span class="cov8" title="1"> if inString </span><span class="cov8" title="1">{
                                if c == '"' || c == '\'' </span><span class="cov8" title="1">{
                                        tokens = append(tokens, cmd[start:i+1])
                                        inString = false
                                }</span>
                        } else<span class="cov8" title="1"> if inWord </span><span class="cov8" title="1">{
                                tokens = append(tokens, cmd[start:i])
                                inWord = false
                        }</span> else<span class="cov8" title="1"> {
                                if c == '"' || c == '\'' </span><span class="cov8" title="1">{
                                        start = i
                                        inString = true
                                }</span> else<span class="cov8" title="1"> if c != ' ' &amp;&amp; c != '.' &amp;&amp; c != endline </span><span class="cov8" title="1">{
                                        tokens = append(tokens, string(c))
                                }</span>
                        }
                case unicode.IsLower(c) &amp;&amp; !inWord &amp;&amp; !inString &amp;&amp; !inNumber:<span class="cov8" title="1">
                        start = i
                        inWord = true</span>
                case unicode.IsUpper(c) &amp;&amp; !inWord &amp;&amp; !inString &amp;&amp; !inNumber:<span class="cov8" title="1">
                        start = i
                        inWord = true</span>
                case unicode.IsNumber(c) &amp;&amp; !inNumber &amp;&amp; !inString &amp;&amp; !inWord:<span class="cov8" title="1">
                        start = i
                        inNumber = true</span>
                default:<span class="cov8" title="1"></span>
                }
        }
        <span class="cov8" title="1">return tokens</span>
}

type compilingDetail struct {
        Token string
        Nexts map[string]*Token
}

func (cd *compilingDetail) String() string <span class="cov8" title="1">{
        expected := "( "
        for _, t := range cd.Nexts </span><span class="cov8" title="1">{
                expected += t.Token + " "
        }</span>
        <span class="cov8" title="1">expected += ")"
        return fmt.Sprintf("near %v expected %v", cd.Token, expected)</span>
}

func compilingStatement(tokens []string) ([]*BIN, error, compilingDetail) <span class="cov8" title="1">{
        pt := _ebnf.GetBase()
        jumps := []*Token{}
        nexts := make(map[string]*Token)
        bin := []*BIN{}
        for _, token := range tokens </span><span class="cov8" title="1">{
                var ok = false
                nexts = _ebnf.FindOptions(pt, &amp;jumps, 0)
                for _, next := range nexts </span><span class="cov8" title="1">{
                        if (next.GetToken() == token) ||
                                (next.GetTokenType() == DynamicReference &amp;&amp; len(token) == 1) ||
                                ((next.GetTokenType() == Object || next.GetTokenType() == Class || next.GetTokenType() == Rule ||
                                        next.GetTokenType() == Attribute || next.GetTokenType() == Constant ||
                                        next.GetTokenType() == Reference) &amp;&amp; unicode.IsUpper(rune(token[0]))) ||
                                (next.GetTokenType() == Text &amp;&amp; (rune(token[0]) == '\'' || rune(token[0]) == '"') ||
                                        (next.GetTokenType() == Constant &amp;&amp; lib.IsNumber(token))) </span><span class="cov8" title="1">{
                                if next.GetTokenType() == Class </span><span class="cov8" title="1">{
                                        if FindClassByName(token, false) != nil </span><span class="cov8" title="1">{
                                                ok = true
                                        }</span>
                                } else<span class="cov8" title="1"> if next.GetTokenType() == Object </span><span class="cov8" title="1">{
                                        if FindObjectByName(token) != nil </span><span class="cov8" title="1">{
                                                ok = true
                                        }</span>
                                } else<span class="cov8" title="1"> if next.GetTokenType() == Rule </span><span class="cov8" title="1">{
                                        if FindRuleByName(token) != nil </span><span class="cov8" title="1">{
                                                ok = true
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        ok = true
                                }</span>
                                <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                                        if pt.Rule_id != next.Rule_id </span><span class="cov8" title="1">{
                                                jumps = append(jumps, pt.Nexts...)
                                        }</span>
                                        <span class="cov8" title="1">pt = next
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if !ok || len(nexts) == 0 </span><span class="cov8" title="1">{
                        return nil, lib.CompilerError, compilingDetail{Token: token, Nexts: nexts}
                }</span>
                <span class="cov8" title="1">code := BIN{TokenType: pt.GetTokenType(), Token: token}
                err := code.CheckLiteralBin()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, inits.Log(err, inits.Error), compilingDetail{}
                }</span>
                <span class="cov8" title="1">bin = append(bin, &amp;code)</span>
        }
        <span class="cov8" title="1">nexts = _ebnf.FindOptions(pt, &amp;jumps, 0)
        for _, y := range nexts </span><span class="cov8" title="1">{
                if y.GetToken() == "." &amp;&amp; y.GetTokenType() == Control </span><span class="cov8" title="1">{
                        return bin, nil, compilingDetail{}
                }</span>
        }
        <span class="cov0" title="0">return nil, lib.CompilerError, compilingDetail{Token: "&lt;end&gt;"}</span>
}

func parsingRule(cmd string) ([]*BIN, error, compilingDetail) <span class="cov8" title="1">{
        return compilingStatement(tokeningStatement(cmd))
}</span>

func linkerRule(r *KBRule, bin []*BIN) error <span class="cov8" title="1">{
        // Find references of objects in KB
        inits.Log("Linking Production Rule: "+r.Name, inits.Info)
        pauseKB()

        dr := make(map[string]*KBClass)
        consequent := -1
        for j, x := range bin </span><span class="cov8" title="1">{
                switch x.LiteralBin </span>{
                case B_initially:<span class="cov8" title="1">
                        stack := KBStack{RuleID: r.ID}
                        stack.Persist()</span>
                case B_then:<span class="cov8" title="1">
                        consequent = j
                        r.consequent = j + 1</span>
                }
                <span class="cov8" title="1">switch x.GetTokentype() </span>{
                case Workspace:<span class="cov0" title="0">
                        if bin[j].workspace == nil </span><span class="cov0" title="0">{
                                bin[j].workspace = FindWorkspaceByName(r.bin[j].Token)
                        }</span>
                case Object:<span class="cov8" title="1">
                        if len(bin[j].objects) == 0 </span><span class="cov8" title="1">{
                                obj := FindObjectByName(bin[j].Token)
                                if obj != nil </span><span class="cov8" title="1">{
                                        bin[j].objects = append(bin[j].objects, obj)
                                }</span>
                        }
                case Class:<span class="cov8" title="1">
                        if bin[j].class == nil </span><span class="cov8" title="1">{
                                c := FindClassByName(x.GetToken(), true)
                                if c == nil </span><span class="cov0" title="0">{
                                        return lib.ClassNotFoundError
                                }</span>
                                <span class="cov8" title="1">bin[j].class = c
                                objs, err := FindAllObjects(bson.M{"class_id": c.ID}, "_id")
                                inits.Log(err, inits.Error)
                                for _, y := range objs </span><span class="cov8" title="1">{
                                        bin[j].objects = append(bin[j].objects, &amp;y)
                                }</span>
                        }
                case Attribute:<span class="cov8" title="1">
                        ref := -1
                        if bin[j+1].LiteralBin == B_of </span><span class="cov8" title="1">{
                                ref = j + 2
                        }</span> else<span class="cov0" title="0"> {
                                for z := j - 1; z &gt;= 0; z-- </span><span class="cov0" title="0">{
                                        if bin[z].GetTokentype() == Object || bin[z].GetTokentype() == Class </span><span class="cov0" title="0">{
                                                ref = z
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">if ref != -1 </span><span class="cov8" title="1">{
                                if bin[ref].GetTokentype() == Object </span><span class="cov0" title="0">{
                                        if len(bin[j].objects) == 0 </span><span class="cov0" title="0">{
                                                obj := FindObjectByName(r.bin[j].Token)
                                                bin[j].objects = append(bin[j].objects, obj)
                                                bin[j].class = obj.ClassPtr
                                        }</span>
                                        <span class="cov0" title="0">bin[j].attribute = bin[ref].class.FindAttribute(x.GetToken())
                                        if len(bin[j].objects) &gt; 0 </span><span class="cov0" title="0">{
                                                atro := FindAttributeObject(bin[ref].objects[0], x.GetToken())
                                                bin[j].attributeObjects = append(bin[j].attributeObjects, atro)
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                } else<span class="cov8" title="1"> if bin[ref].GetTokentype() == Class </span><span class="cov0" title="0">{
                                        c := bin[ref].class
                                        if c == nil </span><span class="cov0" title="0">{
                                                c = FindClassByName(x.GetToken(), true)
                                                bin[ref].class = c
                                        }</span>
                                        <span class="cov0" title="0">bin[j].class = c
                                        bin[j].attribute = c.FindAttribute(x.GetToken())
                                        objs, err := FindAllObjects(bson.M{"class_id": c.ID}, "_id")
                                        inits.Log(err, inits.Fatal)
                                        for _, y := range objs </span><span class="cov0" title="0">{
                                                obj := &amp;y
                                                bin[j].objects = append(bin[j].objects, obj)
                                                atro := FindAttributeObject(obj, x.GetToken())
                                                bin[j].attributeObjects = append(bin[j].attributeObjects, atro)
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                } else<span class="cov8" title="1"> if bin[ref].GetTokentype() == DynamicReference </span><span class="cov0" title="0">{
                                        c := bin[ref].class
                                        if c == nil </span><span class="cov0" title="0">{
                                                c = dr[bin[ref].Token]
                                                bin[ref].class = c
                                        }</span>
                                        <span class="cov0" title="0">if c == nil </span><span class="cov0" title="0">{
                                                return inits.Log("Attribute class not found in KB! "+x.GetToken(), inits.Error)
                                        }</span>
                                        <span class="cov0" title="0">bin[j].attribute = c.FindAttribute(x.GetToken())
                                        objs, err := FindAllObjects(bson.M{"class_id": c.ID}, "_id")
                                        inits.Log(err, inits.Fatal)
                                        for _, y := range objs </span><span class="cov0" title="0">{
                                                obj := &amp;y
                                                bin[j].objects = append(bin[j].objects, obj)
                                                atro := FindAttributeObject(obj, x.GetToken())
                                                bin[j].attributeObjects = append(bin[j].attributeObjects, atro)
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        } else<span class="cov0" title="0"> {
                                return inits.Log("Attribute not found in KB! "+x.GetToken(), inits.Error)
                        }</span>
                case DynamicReference:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                if consequent == -1 </span><span class="cov0" title="0">{
                                        for z := j - 1; z &gt;= 0; z-- </span><span class="cov0" title="0">{
                                                if bin[z].GetTokentype() == Object || bin[z].GetTokentype() == Class </span><span class="cov0" title="0">{
                                                        bin[j].class = bin[z].class
                                                        bin[j].objects = bin[z].objects
                                                        dr[x.Token] = bin[j].class
                                                        break</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> {
                                        for z := consequent - 1; z &gt;= 0; z-- </span><span class="cov0" title="0">{
                                                if bin[z].GetTokentype() == DynamicReference &amp;&amp; bin[z].GetToken() == x.GetToken() </span><span class="cov0" title="0">{
                                                        bin[j].objects = bin[z].objects
                                                        bin[j].class = bin[z].class
                                                        dr[x.Token] = bin[j].class
                                                        break</span>
                                                }
                                        }
                                }
                        }

                case Constant:<span class="cov8" title="1">
                        </span><span class="cov8" title="1">{
                                if !lib.IsNumber(x.GetToken()) </span><span class="cov0" title="0">{
                                        ok := false
                                        for z := j - 1; z &gt;= 0; z-- </span><span class="cov0" title="0">{
                                                if bin[z].GetTokentype() == Attribute </span><span class="cov0" title="0">{
                                                        if bin[z].attribute != nil </span><span class="cov0" title="0">{
                                                                for _, o := range bin[z].attribute.Options </span><span class="cov0" title="0">{
                                                                        if x.GetToken() == o </span><span class="cov0" title="0">{
                                                                                bin[j].Token = "\"" + bin[j].Token + "\""
                                                                                ok = true
                                                                                break</span>
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                                                return inits.Log("List option not found in KB! "+x.GetToken(), inits.Error)
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">a := bin[j].attribute
                if a != nil </span><span class="cov0" title="0">{
                        if consequent != -1 </span><span class="cov0" title="0">{
                                a.addConsequentRules(r)
                        }</span> else<span class="cov0" title="0"> {
                                a.addAntecedentRules(r)
                        }</span>
                }
                <span class="cov8" title="1">cl := bin[j].class
                if cl != nil </span><span class="cov8" title="1">{
                        r.addClass(cl)
                }</span>
                <span class="cov8" title="1">for z := range bin[j].objects </span><span class="cov8" title="1">{
                        bin[j].objects[z].Parsed = true
                }</span>
        }
        <span class="cov8" title="1">r.bin = bin
        resumeKB()
        _rules = append(_rules, *r)
        return nil</span>
}

func RefreshRules() error <span class="cov0" title="0">{
        inits.Log("RefreshRules...", inits.Info)
        for i := range _objects </span><span class="cov0" title="0">{
                if !_objects[i].Parsed </span><span class="cov0" title="0">{
                        for j := range _rules </span><span class="cov0" title="0">{
                                for k := range _rules[j].bkclasses </span><span class="cov0" title="0">{
                                        if _rules[j].bkclasses[k] == _objects[i].ClassPtr </span><span class="cov0" title="0">{
                                                bin, err, _ := parsingRule(_rules[j].Statement)
                                                if inits.Log(err, inits.Error) != nil </span><span class="cov0" title="0">{
                                                        linkerRule(&amp;_rules[j], bin)
                                                }</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">_objects[i].Parsed = true</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func runStackRules() error <span class="cov0" title="0">{
        inits.Log("RunStackRules...", inits.Info)
        for i := range _rules </span><span class="cov0" title="0">{
                if _rules[i].ExecutionInterval != 0 &amp;&amp; time.Now().After(_rules[i].Lastexecution.Add(time.Duration(_rules[i].ExecutionInterval)*time.Millisecond)) </span><span class="cov0" title="0">{
                        stack := KBStack{RuleID: _rules[i].ID}
                        stack.Persist()
                }</span>
        }

        <span class="cov0" title="0">toRun := RunFromStack()
        for _, r := range toRun </span><span class="cov0" title="0">{
                r.Run()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *KBRule) Run() (e error) <span class="cov8" title="1">{

        type Value struct {
                value string
                trust float64
                atype KBAttributeType
        }

        if r.inRun </span><span class="cov0" title="0">{ //avoid non-parallel execution of the same rule
                return
        }</span>
        <span class="cov8" title="1">r.inRun = true
        inits.Log("run..."+r.Name, inits.Info)

        attrs := make(map[string][]*KBAttributeObject)
        objs := make(map[string][]*KBObject)

        trueAntecedent := false
        expression := ""
        fuzzyexp := ""

oulter:
        //Program counter [pc] – It stores the counter which contains the address of the next instruction that is to be executed for the process.
        for pc := 0; pc &lt; len(r.bin); </span><span class="cov8" title="1">{
                switch r.bin[pc].LiteralBin </span>{
                case B_unconditionally:<span class="cov8" title="1">
                        trueAntecedent = true
                        pc++</span>
                case B_then:<span class="cov8" title="1">
                        if trueAntecedent </span><span class="cov8" title="1">{
                                break oulter</span>
                        }
                case B_for:<span class="cov0" title="0">
                        pc++
                        if r.bin[pc].LiteralBin != B_any </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].Token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">pc++
                        if r.bin[pc].TokenType != Class </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].Token, inits.Error)
                        }</span>
                        <span class="cov0" title="0">if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].Token+" KB Class not found!", inits.Error)
                        }</span>

                        <span class="cov0" title="0">if len(r.bin[pc].objects) == 0 </span><span class="cov0" title="0">{
                                return inits.Log("Warning in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].Token+" no object found!", inits.Info)
                        }</span>

                        <span class="cov0" title="0">if r.bin[pc+1].TokenType == DynamicReference </span><span class="cov0" title="0">{
                                pc++
                        }</span>
                case B_if:<span class="cov0" title="0">

                inner:
                        for </span><span class="cov0" title="0">{

                                pc++
                                for ; r.bin[pc].LiteralBin == B_open_par; pc++ </span><span class="cov0" title="0">{
                                        expression = expression + r.bin[pc].Token
                                        fuzzyexp = fuzzyexp + r.bin[pc].Token
                                }</span>
                                <span class="cov0" title="0">if r.bin[pc].LiteralBin != B_the </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].Token, inits.Error)
                                }</span>
                                <span class="cov0" title="0">pc++
                                if r.bin[pc].TokenType != Attribute </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].Token, inits.Error)
                                }</span>

                                <span class="cov0" title="0">if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                        return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].Token, inits.Error)
                                }</span>
                                <span class="cov0" title="0">key := "{{" + r.bin[pc].class.Name + "." + r.bin[pc].Token + "}}"
                                expression = expression + key
                                fuzzyexp = fuzzyexp + key
                                attrs[key] = r.bin[pc].attributeObjects
                                objs[key] = r.bin[pc].objects

                                pc++
                                if r.bin[pc].LiteralBin == B_of </span><span class="cov0" title="0">{
                                        pc++
                                        if r.bin[pc].TokenType != DynamicReference &amp;&amp; r.bin[pc].TokenType != Object </span><span class="cov0" title="0">{
                                                return inits.Log("Error in KB Rule "+r.ID.Hex()+" near "+r.bin[pc].Token, inits.Error)
                                        }</span>
                                        <span class="cov0" title="0">pc++</span>
                                }
                                <span class="cov0" title="0">switch r.bin[pc].LiteralBin </span>{
                                case B_is:<span class="cov0" title="0">
                                        expression = expression + "=="</span>
                                case B_equal:<span class="cov0" title="0">
                                        expression = expression + "=="</span>
                                case B_different:<span class="cov0" title="0">
                                        expression = expression + "!="</span>
                                case B_less:<span class="cov0" title="0">
                                        expression = expression + "&lt;"
                                        pc += 2
                                        if r.bin[pc].LiteralBin == B_or </span><span class="cov0" title="0">{
                                                expression = expression + "="
                                                pc += 2
                                        }</span>
                                case B_greater:<span class="cov0" title="0">
                                        expression = expression + "&gt;"
                                        pc += 2
                                        if r.bin[pc].LiteralBin == B_or </span><span class="cov0" title="0">{
                                                expression = expression + "="
                                                pc += 2
                                        }</span>
                                }
                                <span class="cov0" title="0">pc++
                                if r.bin[pc].TokenType == Constant || r.bin[pc].TokenType == Text || r.bin[pc].TokenType == ListType </span><span class="cov0" title="0">{
                                        expression = expression + r.bin[pc].Token
                                }</span>
                                <span class="cov0" title="0">pc++
                                for ; r.bin[pc].LiteralBin == B_close_par; pc++ </span><span class="cov0" title="0">{
                                        expression = expression + r.bin[pc].Token
                                        fuzzyexp = fuzzyexp + r.bin[pc].Token
                                }</span>

                                <span class="cov0" title="0">switch r.bin[pc].LiteralBin </span>{
                                case B_then:<span class="cov0" title="0">
                                        break inner</span>
                                case B_and:<span class="cov0" title="0">
                                        pc++
                                        expression = expression + " " + r.bin[pc].Token + " "
                                        fuzzyexp = fuzzyexp + " " + r.bin[pc].Token + " "</span>
                                case B_or:<span class="cov0" title="0">
                                        pc++
                                        fuzzyexp = fuzzyexp + " " + r.bin[pc].Token + " "</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        pc++</span>
                }
        }

        <span class="cov8" title="1">if !trueAntecedent </span><span class="cov0" title="0">{
                cart := cartesian.Cartesian{}
                values := make(map[string][]Value)
                idx2 := []string{}
                for ix := range attrs </span><span class="cov0" title="0">{
                        vls := []Value{}
                        cart.AddItem(ix, len(attrs[ix])-1)
                        for iy := range attrs[ix] </span><span class="cov0" title="0">{
                                v, t, at := attrs[ix][iy].ValueString()
                                vls = append(vls, Value{v, t, at})
                        }</span>
                        <span class="cov0" title="0">values[ix] = vls
                        idx2 = append(idx2, ix)</span>
                }

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        exp := expression
                        fuzzy := fuzzy.FuzzyLogicalInference(fuzzyexp)
                        found, idxs := cart.GetCombination()
                        obs := []*KBObject{}
                        ok := true
                        for key := range attrs </span><span class="cov0" title="0">{
                                if values[key][idxs[key]].value != "" </span><span class="cov0" title="0">{
                                        ok = false
                                        break</span>
                                }
                                <span class="cov0" title="0">exp = strings.Replace(exp, key, string(values[key][idxs[key]].value), -1)
                                trust := fmt.Sprint(values[key][idxs[key]].trust)
                                fuzzy = strings.Replace(fuzzy, key, trust, -1)
                                obs = append(obs, objs[key][idxs[key]])</span>
                        }
                        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                result, err := gval.Evaluate(exp, nil)
                                inits.Log(err, inits.Error)
                                trust, err := gval.Evaluate(fuzzy, nil)
                                inits.Log(err, inits.Error)
                                t, _ := strconv.ParseFloat(fmt.Sprintf("%v", trust), 64)
                                if result == true </span><span class="cov0" title="0">{
                                        r.RunConsequent(obs, t)
                                }</span>
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                r.RunConsequent([]*KBObject{}, 100.0)
        }</span>
        <span class="cov8" title="1">r.Lastexecution = time.Now()
        r.Persist()
        r.inRun = false
        return nil</span>
}

type CreateType byte

const (
        NewClass CreateType = iota
        CopyClass
        InheritClass
        NewInstance
)

// TODO: ALTERAR COMAND SET
func RunDetailError(rule string, bin *BIN, pc int) error <span class="cov0" title="0">{
        return errors.New("Error in run rule " + rule + " near " + bin.Token + "[" + strconv.Itoa(pc) + "]!")
}</span>

func (r *KBRule) RunConsequent(objs []*KBObject, trust float64) error <span class="cov8" title="1">{
        //Program counter [pc] – It stores the counter which contains the address of the next instruction that is to be executed for the process.

        for pc := r.consequent; pc &lt; len(r.bin); pc++ </span><span class="cov8" title="1">{
                switch r.bin[pc].LiteralBin </span>{
                case B_inform:<span class="cov0" title="0">
                        attrs := make(map[string][]*KBAttributeObject)
                        cart := cartesian.Cartesian{}
                        pc += 5
                        if r.bin[pc].TokenType != Text </span><span class="cov0" title="0">{
                                return RunDetailError(r.Name, r.bin[pc], pc)
                        }</span>
                        <span class="cov0" title="0">txt := ""
                        ok := true
                        for </span><span class="cov0" title="0">{
                                txt = txt + r.bin[pc].Token
                                pc++
                                if r.bin[pc].LiteralBin != B_the </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">if r.bin[pc].TokenType != Attribute </span><span class="cov0" title="0">{
                                        return RunDetailError(r.Name, r.bin[pc], pc)
                                }</span>
                                <span class="cov0" title="0">if r.bin[pc].attributeObjects == nil </span><span class="cov0" title="0">{
                                        return RunDetailError(r.Name, r.bin[pc], pc)
                                }</span>
                                <span class="cov0" title="0">key := "{{" + r.bin[pc].class.Name + "." + r.bin[pc].Token + "}}"
                                txt = txt + " " + key + " "
                                attrs[key] = r.bin[pc].attributeObjects
                                cart.AddItem(key, len(attrs[key])-1)

                                pc += 2
                                if r.bin[pc].LiteralBin == B_the </span><span class="cov0" title="0">{
                                        pc += 2
                                }</span> else<span class="cov0" title="0"> if r.bin[pc].TokenType != DynamicReference </span><span class="cov0" title="0">{
                                        return RunDetailError(r.Name, r.bin[pc], pc)
                                }</span> else<span class="cov0" title="0"> {
                                        if !attrs[key][pc].InObjects(objs) </span><span class="cov0" title="0">{
                                                ok = false
                                        }</span>
                                        <span class="cov0" title="0">pc++</span>
                                }
                                <span class="cov0" title="0">if r.bin[pc].TokenType == Text </span><span class="cov0" title="0">{
                                        txt = txt + " " + r.bin[pc].Token
                                        pc++
                                }</span>
                        }
                        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                                txtout := txt
                                found, idxs := cart.GetCombination()
                                wks := make(map[primitive.ObjectID]*KBWorkspace)
                                for key := range attrs </span><span class="cov0" title="0">{
                                        ao := attrs[key][idxs[key]]
                                        value, _, _ := ao.ValueString()
                                        txtout = strings.Replace(txtout, key, value, -1)
                                        ws := KBGetWorkspacesFromObject(ao.KbObject)
                                        for w := range ws </span><span class="cov0" title="0">{
                                                wks[ws[w].ID] = ws[w]
                                        }</span>
                                }
                                <span class="cov0" title="0">for k := range wks </span><span class="cov0" title="0">{
                                        wks[k].Posts.Enqueue(txtout)
                                }</span>
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }

                case B_set:<span class="cov0" title="0">
                        pc += 2
                        if r.bin[pc].TokenType != Attribute </span><span class="cov0" title="0">{
                                return RunDetailError(r.Name, r.bin[pc], pc)
                        }</span>
                        <span class="cov0" title="0">if r.bin[pc].attributeObjects == nil </span><span class="cov0" title="0">{
                                return RunDetailError(r.Name, r.bin[pc], pc)
                        }</span>
                        <span class="cov0" title="0">attrs := r.bin[pc].attributeObjects
                        pc += 4
                        if r.bin[pc].TokenType != Constant &amp;&amp; r.bin[pc+1].TokenType != Constant </span><span class="cov0" title="0">{
                                return RunDetailError(r.Name, r.bin[pc], pc)
                        }</span>
                        <span class="cov0" title="0">if r.bin[pc+1].TokenType == Constant </span><span class="cov0" title="0">{
                                pc++
                        }</span>
                        <span class="cov0" title="0">v := r.bin[pc].Token
                        for _, a := range attrs </span><span class="cov0" title="0">{
                                for _, o := range objs </span><span class="cov0" title="0">{
                                        if a.KbObject == o </span><span class="cov0" title="0">{
                                                a.SetValue(v, Inference, trust)
                                        }</span>
                                }
                        }
                case B_create:<span class="cov8" title="1">
                        var baseClass *KBClass
                        var parentClass *KBClass
                        var createType CreateType
                        pc++
                        if r.bin[pc].TokenType != Literal </span><span class="cov0" title="0">{
                                return RunDetailError(r.Name, r.bin[pc], pc)
                        }</span>
                        <span class="cov8" title="1">switch r.bin[pc].LiteralBin </span>{
                        case B_a:<span class="cov8" title="1"> //Class
                                pc += 2
                                switch r.bin[pc].LiteralBin </span>{
                                case B_by:<span class="cov0" title="0">
                                        pc += 2
                                        if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                                return RunDetailError(r.Name, r.bin[pc], pc)
                                        }</span>
                                        <span class="cov0" title="0">createType = CopyClass
                                        baseClass = r.bin[pc].class
                                        pc++</span>
                                case B_whose:<span class="cov0" title="0">
                                        pc += 3
                                        if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                                return RunDetailError(r.Name, r.bin[pc], pc)
                                        }</span>
                                        <span class="cov0" title="0">createType = InheritClass
                                        baseClass = r.bin[pc].class
                                        pc++</span>
                                }
                        case B_an:<span class="cov0" title="0"> //Instance
                                pc += 4
                                if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                        return RunDetailError(r.Name, r.bin[pc], pc)
                                }</span>
                                <span class="cov0" title="0">createType = NewInstance
                                baseClass = r.bin[pc].class</span>
                        default:<span class="cov0" title="0">
                                return RunDetailError(r.Name, r.bin[pc], pc)</span>
                        }
                        <span class="cov8" title="1">if r.bin[pc].LiteralBin == B_named </span><span class="cov8" title="1">{
                                pc += 2
                                name := lib.Identify(r.bin[pc].Token)
                                switch createType </span>{
                                case NewClass:<span class="cov8" title="1">
                                        if _, err := KBClassFactory(name, "", ""); err != nil </span><span class="cov0" title="0">{
                                                return RunDetailError(r.Name, r.bin[pc], pc)
                                        }</span>
                                case CopyClass:<span class="cov0" title="0">
                                        if _, err := KBClassCopy(name, baseClass); err != nil </span><span class="cov0" title="0">{
                                                return RunDetailError(r.Name, r.bin[pc], pc)
                                        }</span>
                                case InheritClass:<span class="cov0" title="0">
                                        if _, err := KBClassFactoryParent(name, "", parentClass); err != nil </span><span class="cov0" title="0">{
                                                return RunDetailError(r.Name, r.bin[pc], pc)
                                        }</span>
                                case NewInstance:<span class="cov0" title="0">
                                        if _, err := ObjectFactoryByClass(name, baseClass); err != nil </span><span class="cov0" title="0">{
                                                return RunDetailError(r.Name, r.bin[pc], pc)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">pc++</span>
                case B_conclude:<span class="cov0" title="0">
                        pc += 6
                        if len(r.bin[pc].attributeObjects) != 1 </span><span class="cov0" title="0">{
                                return RunDetailError(r.Name, r.bin[pc], pc)
                        }</span>
                        <span class="cov0" title="0">attributeObject := r.bin[pc].attributeObjects[0]
                        pc += 2
                        attributeObject.SetValue(r.bin[pc].GetToken(), Inference, trust)</span>
                case B_halt:<span class="cov0" title="0">
                        pauseKB()
                        NewAlert(inits.I18n_halt, "")</span> //All users
                case B_transfer:<span class="cov0" title="0">
                        pc++
                        if len(r.bin[pc].objects) == 0 </span><span class="cov0" title="0">{
                                return RunDetailError(r.Name, r.bin[pc], pc)
                        }</span>
                        <span class="cov0" title="0">obj := r.bin[pc].objects[0]
                        pc += 2
                        if r.bin[pc].workspace == nil </span><span class="cov0" title="0">{
                                return RunDetailError(r.Name, r.bin[pc], pc)
                        }</span>
                        <span class="cov0" title="0">w := r.bin[pc].workspace
                        w.AddObject(obj, 0, 0)</span>
                case B_alter:<span class="cov0" title="0">
                        pc++
                        if r.bin[pc].class == nil </span><span class="cov0" title="0">{
                                return RunDetailError(r.Name, r.bin[pc], pc)
                        }</span>
                        //alterClass := r.bin[pc].class
                        <span class="cov0" title="0">pc++
                        for r.bin[pc].LiteralBin == B_add </span><span class="cov0" title="0">{
                                pc++
                                //attributeName := r.bin[pc].token
                                options := []string{}
                                pc += 2
                                atype := r.bin[pc].Token
                                if KBattributeTypeStr(atype) == KBList </span><span class="cov0" title="0">{
                                        pc++
                                        for r.bin[pc].LiteralBin != B_close_par </span><span class="cov0" title="0">{
                                                pc++
                                                options = append(options, r.bin[pc].Token)
                                                pc++
                                        }</span>
                                }

                        }

                default:<span class="cov0" title="0">
                        return RunDetailError(r.Name, r.bin[pc], pc)</span>
                }

                //TODO: delete
                //TODO: insert
                //TODO: remove
                //TODO: change
                //TODO: move
                //TODO: rotate
                //TODO: show
                //TODO: hide
                //TODO: alter
                //TODO: focus
                //TODO: invoke

        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package models

type KBSource int8

const (
        Undefined KBSource = iota
        FromUser
        IOT
        Simulation
        Inference
)

var KBSourceStr = map[string]KBSource{
        "":           Undefined,
        "User":       FromUser,
        "IOT":        IOT,
        "Inference":  Inference,
        "Simulation": Simulation,
}

func ToKBSources(sources []string) (ret []KBSource) <span class="cov8" title="1">{
        for i := range sources </span><span class="cov8" title="1">{
                ret = append(ret, KBSourceStr[sources[i]])
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package models

import (
        "time"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type StackStatus byte

const (
        Pending StackStatus = iota
        Running
        Concluded
)

type KBStack struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        RuleID           primitive.ObjectID `bson:"rule_id"`
        Status           StackStatus        `bson:"status"`
}

func (obj *KBStack) Persist() error <span class="cov8" title="1">{
        return inits.Persist(obj)
}</span>
func (obj *KBStack) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func StackFactory(id primitive.ObjectID) *KBStack <span class="cov0" title="0">{
        stack := new(KBStack)
        stack.RuleID = id
        inits.Log(stack.Persist(), inits.Fatal)
        return stack
}</span>

func KBAddStack(rules []*KBRule) error <span class="cov0" title="0">{
        for _, r := range rules </span><span class="cov0" title="0">{
                StackFactory(r.ID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func RunFromStack() (list []KBRule) <span class="cov0" title="0">{
        mgm.Coll(new(KBStack)).UpdateMany(mgm.Ctx(), bson.D{{Key: "status", Value: Pending}}, bson.D{{"status", Running}, {"update_at", time.Now().UTC()}})
        ret, err := mgm.Coll(new(KBStack)).Distinct(mgm.Ctx(), "rule_id", bson.D{{"status", Running}})
        inits.Log(err, inits.Error)
        oids := make([]primitive.ObjectID, len(ret))
        for _, id := range ret </span><span class="cov0" title="0">{
                oids = append(oids, id.(primitive.ObjectID))
        }</span>
        <span class="cov0" title="0">opts := options.Find().SetSort(bson.D{{Key: "priority", Value: 1}, {Key: "lastexecution", Value: -1}})
        mgm.Coll(new(KBRule)).SimpleFind(list, bson.D{{Key: "$in", Value: oids}}, opts)
        return</span>
}

func StackEndRun() error <span class="cov0" title="0">{
        _, err := mgm.Coll(new(KBStack)).UpdateMany(mgm.Ctx(), bson.D{{"status", Running}}, bson.D{{"status", Concluded}, {"update_at", time.Now().UTC()}})
        return err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import (
        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        "github.com/asaskevich/govalidator"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "golang.org/x/crypto/bcrypt"
)

type KBUser struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Name             string               `bson:"name" valid:"length(5|50)"`
        Email            string               `bson:"email" valid:"email"`
        Hash             []byte               `bson:"hash" json:"-"`
        Profile          KBProfile            `bson:"profile"`
        Workspaces       []primitive.ObjectID `bson:"workspaces"`
        FaceImage        string               `bson:"faceimage"`
}

func (obj *KBUser) valitade() error <span class="cov0" title="0">{
        _, err := govalidator.ValidateStruct(obj)
        return err
}</span>

func (obj *KBUser) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KBUser) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (user *KBUser) FindOne(p bson.D) error <span class="cov0" title="0">{
        err := mgm.Coll(user).First(p, user)
        return err
}</span>

func NewUser(name, email, pwd, image string) (err error) <span class="cov0" title="0">{
        var copy string
        if image != "" </span><span class="cov0" title="0">{
                copy, err = lib.LoadImage(image)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">u := KBUser{Email: email, Name: name, Hash: hash, FaceImage: copy, Profile: Empty}
        return u.Persist()</span>
}

func InitSecurity() <span class="cov0" title="0">{
        user := KBUser{}
        CheckIndexs()
        err := user.FindOne(bson.D{{Key: "profile", Value: Admin}})
        if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                pwd := lib.GeneratePassword(12, 3, 3, 3)
                hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost)
                inits.Log(err, inits.Fatal)
                user = KBUser{Name: "Default Admin", Email: "admin@k2.com", Hash: hash, Profile: Admin}
                inits.Log(user.Persist(), inits.Fatal)
                inits.Log("Default Hash "+pwd, inits.Info)
        }</span> else<span class="cov0" title="0"> {
                inits.Log(err, inits.Fatal)
        }</span>
}

func CheckIndexs() <span class="cov0" title="0">{
        coll := mgm.Coll(&amp;KBUser{})
        idx := coll.Indexes()
        ret, err := idx.List(mgm.Ctx())
        inits.Log(err, inits.Fatal)
        var results []interface{}
        err = ret.All(mgm.Ctx(), &amp;results)
        inits.Log(err, inits.Fatal)
        if len(results) == 1 </span><span class="cov0" title="0">{
                inits.CreateUniqueIndex(coll, "email")
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "context"
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"
        "github.com/antoniomralmeida/k2/pkg/queue"
        "github.com/kamva/mgm/v3"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type KBWorkspace struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Workspace        string       `bson:"workspace"`
        Top              int          `bson:"top"`
        Left             int          `bson:"left"`
        Width            int          `bson:"width"`
        Height           int          `bson:"height"`
        BackgroundImage  string       `bson:"backgroundimage,omitempty"`
        Objects          []KBObjectWS `bson:"objects"`
        Posts            queue.Queue  `bson:"-"`
}

func WorkspaceFactory(name string, image string) *KBWorkspace <span class="cov0" title="0">{
        copy, err := lib.LoadImage(image)
        if err != nil </span><span class="cov0" title="0">{
                inits.Log(err, inits.Error)
                return nil
        }</span>
        <span class="cov0" title="0">w := KBWorkspace{Workspace: name, BackgroundImage: copy}
        err = w.Persist()
        if err == nil </span><span class="cov0" title="0">{
                _workspaces = append(_workspaces, w)
                return &amp;w
        }</span> else<span class="cov0" title="0"> {
                inits.Log(err, inits.Fatal)
                return nil
        }</span>
}

func (obj *KBWorkspace) ValidateIndex() error <span class="cov0" title="0">{
        cur, err := mgm.Coll(obj).Indexes().List(mgm.Ctx())
        inits.Log(err, inits.Error)
        var result []bson.M
        err = cur.All(context.TODO(), &amp;result)
        if len(result) == 1 </span><span class="cov0" title="0">{
                inits.CreateUniqueIndex(mgm.Coll(obj), "workspace")
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (obj *KBWorkspace) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KBWorkspace) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (w *KBWorkspace) String() string <span class="cov0" title="0">{
        j, err := json.MarshalIndent(*w, "", "\t")
        inits.Log(err, inits.Error)
        return string(j)
}</span>

func (w *KBWorkspace) AddObject(obj *KBObject, left, top int) <span class="cov0" title="0">{
        ows := new(KBObjectWS)
        ows.KBObject = obj
        ows.Object = obj.ID
        ows.Left = left
        ows.Top = top
        w.Objects = append(w.Objects, *ows)
        w.Persist()
}</span>

func FindAllWorkspaces(sort string) error <span class="cov0" title="0">{
        cursor, err := mgm.Coll(new(KBWorkspace)).Find(mgm.Ctx(), bson.D{}, options.Find().SetSort(bson.D{{Key: sort, Value: 1}}))
        inits.Log(err, inits.Fatal)
        err = cursor.All(mgm.Ctx(), &amp;_workspaces)
        return err
}</span>

func FindWorkspaceByName(name string) *KBWorkspace <span class="cov0" title="0">{
        for i := range _workspaces </span><span class="cov0" title="0">{
                if _workspaces[i].Workspace == name </span><span class="cov0" title="0">{
                        return &amp;_workspaces[i]
                }</span>
        }
        <span class="cov0" title="0">inits.Log("Workspace not found!", inits.Error)
        return nil</span>
}

func KBWorkspacesJson() string <span class="cov0" title="0">{
        wks := []KBWorkspace{}

        mgm.Coll(new(KBWorkspace)).SimpleFind(&amp;wks, bson.D{{}})
        ret := []WorkspaceInfo{}
        for _, w := range wks </span><span class="cov0" title="0">{
                ret = append(ret, WorkspaceInfo{Workspace: w.Workspace, BackgroundImage: w.BackgroundImage})
        }</span>
        <span class="cov0" title="0">json, err := json.Marshal(ret)
        inits.Log(err, inits.Error)
        return string(json)</span>
}

func KBGetWorkspacesFromObject(o *KBObject) (ret []*KBWorkspace) <span class="cov0" title="0">{
        //TODO: From mongoDB
        for i := range _workspaces </span><span class="cov0" title="0">{
                for j := range _workspaces[i].Objects </span><span class="cov0" title="0">{
                        if _workspaces[i].Objects[j].KBObject == o </span><span class="cov0" title="0">{
                                ret = append(ret, &amp;_workspaces[i])
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "fmt"
        "os"
        "runtime"
        "sort"
        "sync"
        "time"

        "github.com/kamva/mgm/v3"
        "github.com/madflojo/tasks"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/lib"

        "go.mongodb.org/mongo-driver/bson"

        "go.mongodb.org/mongo-driver/bson/primitive"
)

var (
        kb_current  *KnowledgeBased
        scheduler   *tasks.Scheduler
        _classes    []KBClass
        _workspaces []KBWorkspace
        _rules      []KBRule
        _objects    []KBObject
        _ebnf       *EBNF
)

type KnowledgeBased struct {
        mgm.DefaultModel `json:",inline" bson:",inline"`
        Name             string `bson:"name"`
        RestartFlag      bool   `bson:"-"`
}

func KnowledgeBasedFacotory() *KnowledgeBased <span class="cov0" title="0">{
        kb := new(KnowledgeBased)
        kb.findOne()
        if kb.Name == "" </span><span class="cov0" title="0">{
                kb.Name = "K2 KnowledgeBase System "
        }</span>
        <span class="cov0" title="0">kb.Persist()
        return kb</span>
}

func pauseKB() <span class="cov8" title="1">{
        if scheduler != nil </span><span class="cov0" title="0">{
                scheduler.Lock()
        }</span>
}

func resumeKB() <span class="cov8" title="1">{
        if scheduler != nil </span><span class="cov0" title="0">{
                scheduler.Unlock()
        }</span>
}

func stopKB() <span class="cov0" title="0">{
        if scheduler != nil </span><span class="cov0" title="0">{
                scheduler.Stop()
        }</span>
}

func restartKB() <span class="cov8" title="1">{
        if scheduler != nil </span><span class="cov0" title="0">{
                scheduler.Stop()
                InitKB()
                kb_current.RestartFlag = false
        }</span>
}

func (kb *KnowledgeBased) linkObjects(ws *KBWorkspace, obj *KBObject, left int, top int) <span class="cov0" title="0">{
        ows := KBObjectWS{Object: obj.ID, Left: left, Top: top, KBObject: obj}
        ws.Objects = append(ws.Objects, ows)
        inits.Log(ws.Persist(), inits.Fatal)
}</span>

func (kb *KnowledgeBased) updateKB(name string) error <span class="cov0" title="0">{
        kb.Name = name
        return kb.Persist()
}</span>

func (obj *KnowledgeBased) Persist() error <span class="cov0" title="0">{
        return inits.Persist(obj)

}</span>

func (obj *KnowledgeBased) GetPrimitiveUpdateAt() primitive.DateTime <span class="cov0" title="0">{
        return primitive.NewDateTimeFromTime(obj.UpdatedAt)
}</span>

func (kb *KnowledgeBased) findOne() error <span class="cov0" title="0">{
        ret := mgm.Coll(kb).FindOne(mgm.Ctx(), bson.D{})
        ret.Decode(kb)
        return nil
}</span>

func InitKB() <span class="cov0" title="0">{
        inits.Log("Init KB", inits.Info)
        kb_current = KnowledgeBasedFacotory()

        //Check unique index from database collections
        new(KBClass).ValidateIndex()
        new(KBWorkspace).ValidateIndex()
        new(KBObject).ValidateIndex()

        EBNFFactory("./configs/k2.ebnf")

        FindAllClasses("_id")

        _idxClasses := make(map[primitive.ObjectID]*KBClass)
        for _, c := range _classes </span><span class="cov0" title="0">{
                _idxClasses[c.ID] = &amp;c
        }</span>

        <span class="cov0" title="0">for j, c := range _classes </span><span class="cov0" title="0">{
                inits.Log("Prepare Class "+c.Name, inits.Info)
                if !c.ParentID.IsZero() </span><span class="cov0" title="0">{
                        pc := _idxClasses[c.ParentID]
                        if pc != nil </span><span class="cov0" title="0">{
                                _classes[j].ParentClass = pc
                        }</span> else<span class="cov0" title="0"> {
                                inits.Log("Parent of Class "+c.Name+" not found!", inits.Fatal)
                        }</span>
                }
        }

        <span class="cov0" title="0">_objects, _ := FindAllObjects(bson.M{}, "name")
        for j, o := range _objects </span><span class="cov0" title="0">{
                c := _idxClasses[o.Class]
                if c != nil </span><span class="cov0" title="0">{
                        _objects[j].ClassPtr = c
                        attrs := c.FindAttributes()
                        sort.Slice(attrs, func(i, j int) bool </span><span class="cov0" title="0">{
                                return attrs[i].ID.Hex() &lt; attrs[j].ID.Hex()
                        }</span>)
                        <span class="cov0" title="0">for k, x := range o.Attributes </span><span class="cov0" title="0">{
                                _objects[j].Attributes[k].KbObject = &amp;_objects[j]
                                //kb.Objects[j].Attributes[k].Kb = kb
                                for l, y := range attrs </span><span class="cov0" title="0">{
                                        if y.ID == x.Attribute </span><span class="cov0" title="0">{
                                                _objects[j].Attributes[k].KbAttribute = attrs[l]
                                                break</span>
                                        }
                                        <span class="cov0" title="0">if y.ID.Hex() &gt; x.Attribute.Hex() </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if _objects[j].Attributes[k].KbAttribute == nil </span><span class="cov0" title="0">{
                                        inits.Log("Attribute not found "+x.Attribute.Hex(), inits.Fatal)
                                }</span>

                                //Last value
                                <span class="cov0" title="0">h := KBHistory{}
                                err := h.FindLast(bson.D{{Key: "attribute_id", Value: x.ID}})
                                if err != nil </span><span class="cov0" title="0">{
                                        if err.Error() != "not found" </span><span class="cov0" title="0">{
                                                inits.Log(err, inits.Fatal)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        _objects[j].Attributes[k].KbHistory = &amp;h
                                }</span>
                                <span class="cov0" title="0">_objects[j].Attributes[k].Validity()</span>
                        }
                } else<span class="cov0" title="0"> {
                        inits.Log("Class of object "+o.Name+" not found!", inits.Fatal)
                }</span>
        }

        <span class="cov0" title="0">FindAllWorkspaces("name")

        FindAllRules("_id", &amp;_rules)

        for i := range _rules </span><span class="cov0" title="0">{
                bin, err, _ := parsingRule(_rules[i].Statement)
                inits.Log(err, inits.Fatal)
                if err == nil </span><span class="cov0" title="0">{
                        linkerRule(&amp;_rules[i], bin)
                }</span>
        }
}

func KBRun(wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()

        // Start the Scheduler
        scheduler = tasks.New()
        defer scheduler.Stop()

        // Add tasks
        _, err := scheduler.Add(&amp;tasks.Task{
                Interval: time.Duration(2 * time.Second),

                TaskFunc: func() error </span><span class="cov0" title="0">{
                        go runStackRules()
                        return nil
                }</span>,
        })
        <span class="cov0" title="0">inits.Log(err, inits.Fatal)
        _, err = scheduler.Add(&amp;tasks.Task{
                Interval: time.Duration(60 * time.Second),
                TaskFunc: func() error </span><span class="cov0" title="0">{
                        go RefreshRules()
                        return nil
                }</span>,
        })
        <span class="cov0" title="0">inits.Log(err, inits.Fatal)

        inits.Log("K2 KB System started!", inits.Info)
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                fmt.Println("K2 KB System started! Press ESC to shutdown")
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if lib.KeyPress() == 27 </span><span class="cov0" title="0">{
                        fmt.Printf("Shutdown...")
                        stopKB()
                        wg.Done()
                        os.Exit(0)
                }</span>
                <span class="cov0" title="0">if kb_current.RestartFlag </span><span class="cov0" title="0">{
                        restartKB()
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

type LiteralBin byte

const (
        B_null LiteralBin = iota
        B_a
        B_activate
        B_add
        B_alter
        B_an
        B_and
        B_any
        B_are
        B_as
        B_at
        B_blue
        B_breakpoints
        B_by
        B_change
        B_class
        B_cloning
        B_close_par
        B_comma
        B_conclude
        B_create
        B_date
        B_deactivate
        B_degrees
        B_delete
        B_different
        B_enabled
        B_end
        B_equal
        B_equal_sym
        B_first_task
        B_focus
        B_for
        B_from
        B_greater
        B_green
        B_halt
        B_hide
        B_history
        B_if
        B_inference
        B_inform
        B_initially
        B_insert
        B_instance
        B_invoke
        B_iot
        B_is
        B_keep
        B_less
        B_linearregression
        B_list
        B_method
        B_montecarlo
        B_move
        B_named
        B_normaldistribution
        B_number
        B_of
        B_on
        B_open_par
        B_operator
        B_or
        B_parent
        B_red
        B_remove
        B_rotate
        B_set
        B_show
        B_simulation
        B_start
        B_string
        B_task_queue
        B_than
        B_that
        B_the
        B_then
        B_to
        B_transfer
        B_unconditionally
        B_user
        B_validity
        B_when
        B_whenever
        B_whose
        B_with
        B_yellow
)

var LiteralBinStr = map[string]LiteralBin{
        "":                   B_null,
        "a":                  B_a,
        "activate":           B_activate,
        "add":                B_add,
        "alter":              B_alter,
        "an":                 B_an,
        "and":                B_and,
        "any":                B_any,
        "are":                B_are,
        "as":                 B_as,
        "at":                 B_at,
        "blue":               B_blue,
        "breakpoints":        B_breakpoints,
        "by":                 B_by,
        "change":             B_change,
        "class":              B_class,
        "cloning":            B_cloning,
        ")":                  B_close_par,
        ",":                  B_comma,
        "conclude":           B_conclude,
        "create":             B_create,
        "Date":               B_date,
        "deactivate":         B_deactivate,
        "degrees":            B_degrees,
        "delete":             B_delete,
        "different":          B_different,
        "enabled":            B_enabled,
        "end":                B_end,
        "equal":              B_equal,
        "=":                  B_equal_sym,
        "first-task":         B_first_task,
        "focus":              B_focus,
        "for":                B_for,
        "from":               B_from,
        "greater":            B_greater,
        "green":              B_green,
        "halt":               B_halt,
        "hide":               B_hide,
        "history":            B_history,
        "if":                 B_if,
        "Inference":          B_inference,
        "inform":             B_inform,
        "initially":          B_initially,
        "insert":             B_insert,
        "instance":           B_instance,
        "invoke":             B_invoke,
        "IOT":                B_iot,
        "is":                 B_is,
        "keep":               B_keep,
        "less":               B_less,
        "LinearRegression":   B_linearregression,
        "List":               B_list,
        "method":             B_method,
        "MonteCarlo":         B_montecarlo,
        "move":               B_move,
        "named":              B_named,
        "NormalDistribution": B_normaldistribution,
        "Number":             B_number,
        "of":                 B_of,
        "on":                 B_on,
        "(":                  B_open_par,
        "operator":           B_operator,
        "or":                 B_or,
        "parent":             B_parent,
        "red":                B_red,
        "remove":             B_remove,
        "rotate":             B_rotate,
        "set":                B_set,
        "show":               B_show,
        "Simulation":         B_simulation,
        "start":              B_start,
        "String":             B_string,
        "task-queue":         B_task_queue,
        "than":               B_than,
        "that":               B_that,
        "the":                B_the,
        "then":               B_then,
        "to":                 B_to,
        "transfer":           B_transfer,
        "unconditionally":    B_unconditionally,
        "User":               B_user,
        "validity":           B_validity,
        "when":               B_when,
        "whenever":           B_whenever,
        "whose":              B_whose,
        "with":               B_with,
        "yellow":             B_yellow,
}

func (me LiteralBin) String() string <span class="cov0" title="0">{
        return string(me)
}</span>

func (me LiteralBin) Size() int <span class="cov0" title="0">{
        return len(LiteralBinStr)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

type PAIR struct {
        begin int
        end   int
}

func findPair(p []PAIR, i int) int <span class="cov8" title="1">{
        var ret = 0
        for k, x := range p </span><span class="cov8" title="1">{
                if x.begin &lt;= i &amp;&amp; x.end &gt;= i &amp;&amp; (p[k].begin &gt; p[ret].begin || p[k].end &lt; p[ret].end) </span><span class="cov8" title="1">{
                        ret = k
                }</span>
        }
        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package models

import (
        "encoding/json"

        "github.com/antoniomralmeida/k2/internal/inits"
)

type Statement struct {
        Id     int      `json:"id"`
        Name   string   `json:"name"`
        Tokens []*Token `json:"tokens"`
}

func (s *Statement) String() string <span class="cov0" title="0">{
        ret, err := json.MarshalIndent(s, "", "    ")
        inits.Log(err, inits.Error)
        return string(ret)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "strconv"
)

type Token struct {
        Id        int       `json:"id"`
        Tokentype TokenType `json:"tokentype"`
        Rule_id   int       `json:"rule_id"`
        Rule_jump int       `json:"rule_jump"`
        Token     string    `json:"token"`
        Nexts     []*Token  `json:"-"`
}

func (t *Token) GetToken() string <span class="cov8" title="1">{
        return t.Token
}</span>

func (t *Token) GetTokenType() TokenType <span class="cov8" title="1">{
        return t.Tokentype
}</span>

func (t *Token) GetNexts() []*Token <span class="cov0" title="0">{
        return t.Nexts
}</span>

func (t *Token) String() string <span class="cov8" title="1">{
        return "#" + strconv.Itoa(t.Id) + ", token: " + t.Token + ", type:" + t.Tokentype.String()
}</span>

func (t *Token) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        var result map[string]string = make(map[string]string)
        result["Id"] = strconv.Itoa(t.Id)
        result["Tokentype"] = t.Tokentype.String()
        result["Rule_id"] = strconv.Itoa(t.Rule_id)
        result["Rule_jump"] = strconv.Itoa(t.Rule_jump)
        result["Token"] = t.Token
        result["Nexts"] = fmt.Sprintf("%v", t.Nexts)
        return json.Marshal(&amp;result)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package models

type TokenType byte

const (
        Null TokenType = iota
        Reference
        Literal
        Text
        Control
        Jump
        Object
        DynamicReference
        Attribute
        Constant
        Class
        ListType
        Workspace
        Rule
)

var TokentypeStr = []string{"", "Reference", "Literal", "Text", "Control", "Jump", "Object", "DynamicReference", "Attribute", "Constant", "Class", "ListType", "Workspace", "Rule"}

func (me TokenType) String() string <span class="cov8" title="1">{
        return TokentypeStr[me]
}</span>

func (me TokenType) Size() int <span class="cov8" title="1">{
        return len(TokentypeStr)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package date

import (
        "regexp"
        "strings"
        "time"
)

// PatternTranslation are the map of regexs in different languages
var PatternTranslation = map[string]PatternTranslations{
        "en": {
                DateRegex: `(of )?(the )?((after )?tomorrow|((today|tonight)|(next )?(monday|tuesday|wednesday|thursday|friday|saturday|sunday))|(\d{2}|\d)(th|rd|st|nd)? (of )?(january|february|march|april|may|june|july|august|september|october|november|december)|((\d{2}|\d)/(\d{2}|\d)))`,
                TimeRegex: `(at )?(\d{2}|\d)(:\d{2}|\d)?( )?(pm|am|p\.m|a\.m)`,
        },
        "de": {
                DateRegex: `(von )?(das )?((nach )?morgen|((heute|abends)|(nächsten )?(montag|dienstag|mittwoch|donnerstag|freitag|samstag|sonntag))|(\d{2}|\d)(th|rd|st|nd)? (of )?(januar|februar|märz|april|mai|juli|juli|august|september|oktober|november|dezember)|((\d{2}|\d)/(\d{2}|\d)))`,
                TimeRegex: `(um )?(\d{2}|\d)(:\d{2}|\d)?( )?(pm|am|p\.m|a\.m)`,
        },
        "fr": {
                DateRegex: `(le )?(après )?demain|((aujourd'hui'|ce soir)|(lundi|mardi|mecredi|jeudi|vendredi|samedi|dimanche)( prochain)?|(\d{2}|\d) (janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)|((\d{2}|\d)/(\d{2}|\d)))`,
                TimeRegex: `(à )?(\d{2}|\d)(:\d{2}|\d)?( )?(pm|am|p\.m|a\.m)`,
        },
        "es": {
                DateRegex: `(el )?((pasado )?mañana|((hoy|esta noche)|(el )?(proximo )?(lunes|martes|miercoles|jueves|viernes|sabado|domingo))|(\d{2}|\d) (de )?(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)|((\d{2}|\d)/(\d{2}|\d)))`,
                TimeRegex: `(a )?(las )?(\d{2}|\d)(:\d{2}|\d)?( )?(de )?(la )?(pm|am|p\.m|a\.m|tarde|mañana)`,
        },
        "ca": {
                DateRegex: `(el )?((després )?(de )?demà|((avui|aquesta nit)|(el )?(proper )?(dilluns|dimarts|dimecres|dijous|divendres|dissabte|diumenge))|(\d{2}|\d) (de )?(gener|febrer|març|abril|maig|juny|juliol|agost|setembre|octubre|novembre|desembre)|((\d{2}|\d)/(\d{2}|\d)))`,
                TimeRegex: `(a )?(les )?(\d{2}|\d)(:\d{2}|\d)?( )?(pm|am|p\.m|a\.m)`,
        },
        "nl": {
                DateRegex: `(van )?(de )?((na )?morgen|((vandaag|vanavond)|(volgende )?(maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag|zondag))|(\d{2}|\d)(te|de)? (vab )?(januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december)|((\d{2}|\d)/(\d{2}|\d)))`,
                TimeRegex: `(om )?(\d{2}|\d)(:\d{2}|\d)?( )?(pm|am|p\.m|a\.m)`,
        },
        "el": {
                DateRegex: `(από )?(το )?((μεθ )?αύριο|((σήμερα|απόψε)|(επόμενη )?(δευτέρα|τρίτη|τετάρτη|πέμπτη|παρασκευή|σάββατο|κυριακή))|(\d{2}|\d)(η)? (of )?(ιανουάριος|φεβρουάριος|μάρτιος|απρίλιος|μάιος|ιούνιος|ιούλιος|αύγουστος|σεπτέμβριος|οκτώβριος|νοέμβριος|δεκέμβριος)|((\d{2}|\d)/(\d{2}|\d)))`,
                TimeRegex: `(at )?(\d{2}|\d)(:\d{2}|\d)?( )?(μμ|πμ|μ\.μ|π\.μ)`,
        },
}

// PatternTranslations are the translations of the regexs for dates
type PatternTranslations struct {
        DateRegex string
        TimeRegex string
}

// SearchTime returns the found date in the given sentence and the sentence without the date, if no date has
// been found, it returns an empty date and the given sentence.
func SearchTime(locale, sentence string) (string, time.Time) <span class="cov0" title="0">{
        _time := RuleTime(sentence)
        // Set the time to 12am if no time has been found
        if _time == (time.Time{}) </span><span class="cov0" title="0">{
                _time = time.Date(0, 0, 0, 12, 0, 0, 0, time.UTC)
        }</span>

        <span class="cov0" title="0">for _, rule := range rules </span><span class="cov0" title="0">{
                date := rule(locale, sentence)

                // If the current rule found a date
                if date != (time.Time{}) </span><span class="cov0" title="0">{
                        date = time.Date(date.Year(), date.Month(), date.Day(), _time.Hour(), _time.Minute(), 0, 0, time.UTC)

                        sentence = DeleteTimes(locale, sentence)
                        return DeleteDates(locale, sentence), date
                }</span>
        }

        <span class="cov0" title="0">return sentence, time.Now().Add(time.Hour * 24)</span>
}

// DeleteDates removes the dates of the given sentence and returns it
func DeleteDates(locale, sentence string) string <span class="cov8" title="1">{
        // Create a regex to match the patterns of dates to remove them.
        datePatterns := regexp.MustCompile(PatternTranslation[locale].DateRegex)

        // Replace the dates by empty string
        sentence = datePatterns.ReplaceAllString(sentence, "")
        // Trim the spaces and return
        return strings.TrimSpace(sentence)
}</span>

// DeleteTimes removes the times of the given sentence and returns it
func DeleteTimes(locale, sentence string) string <span class="cov8" title="1">{
        // Create a regex to match the patterns of times to remove them.
        timePatterns := regexp.MustCompile(PatternTranslation[locale].TimeRegex)

        // Replace the times by empty string
        sentence = timePatterns.ReplaceAllString(sentence, "")
        // Trim the spaces and return
        return strings.TrimSpace(sentence)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package date

import "time"

// A Rule is a function that takes the given sentence and tries to parse a specific
// rule to return a date, if not, the date is empty.
type Rule func(string, string) time.Time

var rules []Rule

// RegisterRule takes a rule in parameter and register it to the array of rules
func RegisterRule(rule Rule) <span class="cov8" title="1">{
        rules = append(rules, rule)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package date

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/antoniomralmeida/k2/internal/olivia/util"
)

const day = time.Hour * 24

// RuleTranslations are the translations of the rules in different languages
var RuleTranslations = map[string]RuleTranslation{
        "en": {
                DaysOfWeek: []string{
                        "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday",
                },
                Months: []string{
                        "january", "february", "march", "april", "may", "june", "july",
                        "august", "september", "october", "november", "december",
                },
                RuleToday:         `today|tonight`,
                RuleTomorrow:      `(after )?tomorrow`,
                RuleAfterTomorrow: "after",
                RuleDayOfWeek:     `(next )?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)`,
                RuleNextDayOfWeek: "next",
                RuleNaturalDate:   `january|february|march|april|may|june|july|august|september|october|november|december`,
        },
        "de": {
                DaysOfWeek: []string{
                        "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag", "Sonntag",
                },
                Months: []string{
                        "Januar", "Februar", "Marsch", "April", "Mai", "Juni", "Juli",
                        "August", "September", "Oktober", "November", "Dezember",
                },
                RuleToday:         `heute|abends`,
                RuleTomorrow:      `(nach )?tomorrow`,
                RuleAfterTomorrow: "nach",
                RuleDayOfWeek:     `(nächsten )?(Montag|Dienstag|Mittwoch|Donnerstag|Freitag|Samstag|Sonntag)`,
                RuleNextDayOfWeek: "nächste",
                RuleNaturalDate:   `Januar|Februar|März|April|Mai|Juli|Juli|August|September|Oktober|November|Dezember`,
        },
        "fr": {
                DaysOfWeek: []string{
                        "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi", "dimanche",
                },
                Months: []string{
                        "janvier", "février", "mars", "avril", "mai", "juin", "juillet",
                        "août", "septembre", "octobre", "novembre", "décembre",
                },
                RuleToday:         `aujourd'hui|ce soir`,
                RuleTomorrow:      `(après )?demain`,
                RuleAfterTomorrow: "après",
                RuleDayOfWeek:     `(lundi|mardi|mecredi|jeudi|vendredi|samedi|dimanche)( prochain)?`,
                RuleNextDayOfWeek: "prochain",
                RuleNaturalDate:   `janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre`,
        },
        "es": {
                DaysOfWeek: []string{
                        "lunes", "martes", "miercoles", "jueves", "viernes", "sabado", "domingo",
                },
                Months: []string{
                        "enero", "febrero", "marzo", "abril", "mayo", "junio", "julio",
                        "agosto", "septiembre", "octubre", "noviembre", "diciembre",
                },
                RuleToday:         `hoy|esta noche`,
                RuleTomorrow:      `(pasado )?mañana`,
                RuleAfterTomorrow: "pasado",
                RuleDayOfWeek:     `(el )?(proximo )?(lunes|martes|miercoles|jueves|viernes|sabado|domingo))`,
                RuleNextDayOfWeek: "proximo",
                RuleNaturalDate:   `enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre`,
        },
        "ca": {
                DaysOfWeek: []string{
                        "dilluns", "dimarts", "dimecres", "dijous", "divendres", "dissabte", "diumenge",
                },
                Months: []string{
                        "gener", "febrer", "març", "abril", "maig", "juny", "juliol",
                        "agost", "setembre", "octubre", "novembre", "desembre",
                },
                RuleToday:         `avui|aquesta nit`,
                RuleTomorrow:      `((després )?(de )?demà`,
                RuleAfterTomorrow: "després",
                RuleDayOfWeek:     `(el )?(proper )?(dilluns|dimarts|dimecres|dijous|divendres|dissabte|diumenge))`,
                RuleNextDayOfWeek: "proper",
                RuleNaturalDate:   `gener|febrer|març|abril|maig|juny|juliol|agost|setembre|octubre|novembre|desembre`,
        },
        "nl": {
                DaysOfWeek: []string{
                        "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag", "zondag",
                },
                Months: []string{
                        "januari", "februari", "maart", "april", "mei", "juni", "juli",
                        "augustus", "september", "oktober", "november", "december",
                },
                RuleToday:         `vandaag|vanavond`,
                RuleTomorrow:      `(na )?morgen`,
                RuleAfterTomorrow: "na",
                RuleDayOfWeek:     `(volgende )?(maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag|zondag)`,
                RuleNextDayOfWeek: "volgende",
                RuleNaturalDate:   `januari|februari|maart|april|mei|juni|juli|augustus|september|oktober|november|december`,
        },
        "el": {
                DaysOfWeek: []string{
                        "δευτέρα", "τρίτη", "τετάρτη", "πέμπτη", "παρασκευή", "σάββατο", "κυριακή",
                },
                Months: []string{
                        "ιανουάριος", "φεβρουάριος", "μάρτιος", "απρίλιος", "μάιος", "ιούνιος", "ιούλιος",
                        "αύγουστος", "σεπτέμβριος", "οκτώβριος", "νοέμβριος", "δεκέμβριος",
                },
                RuleToday:         `σήμερα|απόψε`,
                RuleTomorrow:      `(μεθ )?άυριο`,
                RuleAfterTomorrow: "μεθ",
                RuleDayOfWeek:     `(επόμενη )?(δευτέρα|τρίτη|τετάρτη|πέμπτη|παρασκευή|σάββατο|κυριακή)`,
                RuleNextDayOfWeek: "επόμενη",
                RuleNaturalDate:   `ιανουάριος|φεβρουάριος|μάρτιος|απρίλιος|μάιος|ιούνιος|ιούλιος|αύγουστος|σεπτέμβριος|οκτώβριος|νοέμβριος|δεκέμβριος`,
        },
}

// A RuleTranslation is all the texts/regexs to match the dates
type RuleTranslation struct {
        DaysOfWeek        []string
        Months            []string
        RuleToday         string
        RuleTomorrow      string
        RuleAfterTomorrow string
        RuleDayOfWeek     string
        RuleNextDayOfWeek string
        RuleNaturalDate   string
}

var daysOfWeek = map[string]time.Weekday{
        "monday":    time.Monday,
        "tuesday":   time.Tuesday,
        "wednesday": time.Wednesday,
        "thursday":  time.Thursday,
        "friday":    time.Friday,
        "saturday":  time.Saturday,
        "sunday":    time.Sunday,
}

func init() <span class="cov8" title="1">{
        // Register the rules
        RegisterRule(RuleToday)
        RegisterRule(RuleTomorrow)
        RegisterRule(RuleDayOfWeek)
        RegisterRule(RuleNaturalDate)
        RegisterRule(RuleDate)
}</span>

// RuleToday checks for today, tonight, this afternoon dates in the given sentence, then
// it returns the date parsed.
func RuleToday(locale, sentence string) (result time.Time) <span class="cov8" title="1">{
        todayRegex := regexp.MustCompile(RuleTranslations[locale].RuleToday)
        today := todayRegex.FindString(sentence)

        // Returns an empty date struct if no date has been found
        if today == "" </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov8" title="1">return time.Now()</span>
}

// RuleTomorrow checks for "tomorrow" and "after tomorrow" dates in the given sentence, then
// it returns the date parsed.
func RuleTomorrow(locale, sentence string) (result time.Time) <span class="cov8" title="1">{
        tomorrowRegex := regexp.MustCompile(RuleTranslations[locale].RuleTomorrow)
        date := tomorrowRegex.FindString(sentence)

        // Returns an empty date struct if no date has been found
        if date == "" </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov8" title="1">result = time.Now().Add(day)

        // If the date contains "after", we add 24 hours to tomorrow's date
        if strings.Contains(date, RuleTranslations[locale].RuleAfterTomorrow) </span><span class="cov8" title="1">{
                return result.Add(day)
        }</span>

        <span class="cov8" title="1">return</span>
}

// RuleDayOfWeek checks for the days of the week and the keyword "next" in the given sentence,
// then it returns the date parsed.
func RuleDayOfWeek(locale, sentence string) time.Time <span class="cov8" title="1">{
        dayOfWeekRegex := regexp.MustCompile(RuleTranslations[locale].RuleDayOfWeek)
        date := dayOfWeekRegex.FindString(sentence)

        // Returns an empty date struct if no date has been found
        if date == "" </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov8" title="1">var foundDayOfWeek int
        // Find the integer value of the found day of the week
        for _, dayOfWeek := range daysOfWeek </span><span class="cov8" title="1">{
                // Down case the day of the week to match the found date
                stringDayOfWeek := strings.ToLower(dayOfWeek.String())

                if strings.Contains(date, stringDayOfWeek) </span><span class="cov8" title="1">{
                        foundDayOfWeek = int(dayOfWeek)
                }</span>
        }

        <span class="cov8" title="1">currentDay := int(time.Now().Weekday())
        // Calculate the date of the found day
        calculatedDate := foundDayOfWeek - currentDay

        // If the day is already passed in the current week, then we add another week to the count
        if calculatedDate &lt;= 0 </span><span class="cov0" title="0">{
                calculatedDate += 7
        }</span>

        // If there is "next" in the sentence, then we add another week
        <span class="cov8" title="1">if strings.Contains(date, RuleTranslations[locale].RuleNextDayOfWeek) </span><span class="cov0" title="0">{
                calculatedDate += 7
        }</span>

        // Then add the calculated number of day to the actual date
        <span class="cov8" title="1">return time.Now().Add(day * time.Duration(calculatedDate))</span>
}

// RuleNaturalDate checks for the dates written in natural language in the given sentence,
// then it returns the date parsed.
func RuleNaturalDate(locale, sentence string) time.Time <span class="cov8" title="1">{
        naturalMonthRegex := regexp.MustCompile(
                RuleTranslations[locale].RuleNaturalDate,
        )
        naturalDayRegex := regexp.MustCompile(`\d{2}|\d`)

        month := naturalMonthRegex.FindString(sentence)
        day := naturalDayRegex.FindString(sentence)

        // Put the month in english to parse the time with time golang package
        if locale != "en" </span><span class="cov0" title="0">{
                monthIndex := util.Index(RuleTranslations[locale].Months, month)
                month = RuleTranslations["en"].Months[monthIndex]
        }</span>

        <span class="cov8" title="1">parsedMonth, _ := time.Parse("January", month)
        parsedDay, _ := strconv.Atoi(day)

        // Returns an empty date struct if no date has been found
        if day == "" &amp;&amp; month == "" </span><span class="cov8" title="1">{
                return time.Time{}
        }</span>

        // If only the month is specified
        <span class="cov8" title="1">if day == "" </span><span class="cov8" title="1">{
                // Calculate the number of months to add
                calculatedMonth := parsedMonth.Month() - time.Now().Month()
                // Add a year if the month is passed
                if calculatedMonth &lt;= 0 </span><span class="cov0" title="0">{
                        calculatedMonth += 12
                }</span>

                // Remove the number of days elapsed in the month to reach the first
                <span class="cov8" title="1">return time.Now().AddDate(0, int(calculatedMonth), -time.Now().Day()+1)</span>
        }

        // Parse the date
        <span class="cov8" title="1">parsedDate := fmt.Sprintf("%d-%02d-%02d", time.Now().Year(), parsedMonth.Month(), parsedDay)
        date, err := time.Parse("2006-01-02", parsedDate)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        // If the date has been passed, add a year
        <span class="cov8" title="1">if time.Now().After(date) </span><span class="cov0" title="0">{
                date = date.AddDate(1, 0, 0)
        }</span>

        <span class="cov8" title="1">return date</span>
}

// RuleDate checks for dates written like mm/dd
func RuleDate(locale, sentence string) time.Time <span class="cov8" title="1">{
        dateRegex := regexp.MustCompile(`(\d{2}|\d)/(\d{2}|\d)`)
        date := dateRegex.FindString(sentence)

        // Returns an empty date struct if no date has been found
        if date == "" </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        // Parse the found date
        <span class="cov8" title="1">parsedDate, err := time.Parse("01/02", date)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        // Add the current year to the date
        <span class="cov8" title="1">parsedDate = parsedDate.AddDate(time.Now().Year(), 0, 0)

        // Add another year if the date is passed
        if time.Now().After(parsedDate) </span><span class="cov0" title="0">{
                parsedDate = parsedDate.AddDate(1, 0, 0)
        }</span>

        <span class="cov8" title="1">return parsedDate</span>
}

// RuleTime checks for an hour written like 9pm
func RuleTime(sentence string) time.Time <span class="cov8" title="1">{
        timeRegex := regexp.MustCompile(`(\d{2}|\d)(:\d{2}|\d)?( )?(pm|am|p\.m|a\.m)`)
        foundTime := timeRegex.FindString(sentence)

        // Returns an empty date struct if no date has been found
        if foundTime == "" </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        // Initialize the part of the day asked
        <span class="cov8" title="1">var part string
        if strings.Contains(foundTime, "pm") || strings.Contains(foundTime, "p.m") </span><span class="cov8" title="1">{
                part = "pm"
        }</span> else<span class="cov0" title="0"> if strings.Contains(foundTime, "am") || strings.Contains(foundTime, "a.m") </span><span class="cov0" title="0">{
                part = "am"
        }</span>

        <span class="cov8" title="1">if strings.Contains(foundTime, ":") </span><span class="cov8" title="1">{
                // Get the hours and minutes of the given time
                hoursAndMinutesRegex := regexp.MustCompile(`(\d{2}|\d):(\d{2}|\d)`)
                timeVariables := strings.Split(hoursAndMinutesRegex.FindString(foundTime), ":")

                // Format the time with 2 digits for each
                formattedTime := fmt.Sprintf("%02s:%02s %s", timeVariables[0], timeVariables[1], part)
                response, _ := time.Parse("03:04 pm", formattedTime)

                return response
        }</span>

        <span class="cov0" title="0">digitsRegex := regexp.MustCompile(`\d{2}|\d`)
        foundDigits := digitsRegex.FindString(foundTime)

        formattedTime := fmt.Sprintf("%02s %s", foundDigits, part)
        response, _ := time.Parse("03 pm", formattedTime)

        return response</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package locales

import "github.com/antoniomralmeida/k2/internal/inits"

// Import these packages to trigger the init() function

// Locales is the list of locales's tags and names
// Please check if the language is supported in https://github.com/tebeka/snowball,
// if it is please add the correct language name.

func InitStem() <span class="cov0" title="0">{
        for key := range inits.Locales </span><span class="cov0" title="0">{
                st, err := inits.NewStem(key)
                if err != nil </span><span class="cov0" title="0">{
                        inits.Log(err, inits.Error)
                }</span> else<span class="cov0" title="0"> {
                        l := inits.Locales[key]
                        l.Stemmer = st
                        inits.Locales[key] = l
                }</span>
        }
}

// GetNameByTag returns the name of the given locale's tag
func GetNameByTag(tag string) string <span class="cov8" title="1">{
        return inits.Locales[tag].Description
}</span>

// GetTagByName returns the tag of the given locale's name
func GetTagByName(name string) string <span class="cov8" title="1">{

        for key, value := range inits.Locales </span><span class="cov0" title="0">{
                if value.Description == name </span><span class="cov0" title="0">{
                        return key
                }</span>
        }
        <span class="cov8" title="1">return inits.DefaultLocale</span>
}

func GetLocaleByName(name string) inits.Locale <span class="cov0" title="0">{
        for key, value := range inits.Locales </span><span class="cov0" title="0">{
                if value.Description == name </span><span class="cov0" title="0">{
                        return inits.Locales[key]
                }</span>
        }
        <span class="cov0" title="0">return inits.Locales[inits.DefaultLocale]</span>
}

// Exists checks if the given tag exists in the list of locales
func Exists(tag string) bool <span class="cov8" title="1">{
        _, ok := inits.Locales[tag]
        return ok
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package network

// Derivative contains the derivatives of `z` and the adjustments
type Derivative struct {
        Delta      Matrix
        Adjustment Matrix
}

// ComputeLastLayerDerivatives returns the derivatives of the last layer L
func (network Network) ComputeLastLayerDerivatives() Derivative <span class="cov0" title="0">{
        l := len(network.Layers) - 1
        lastLayer := network.Layers[l]

        // Compute derivative for the last layer of weights and biases
        cost := Difference(network.Output, lastLayer)
        sigmoidDerivative := Multiplication(lastLayer, ApplyFunction(lastLayer, SubtractsOne))

        // Compute delta and the weights' adjustment
        delta := Multiplication(
                ApplyFunction(cost, MultipliesByTwo),
                sigmoidDerivative,
        )
        weights := DotProduct(Transpose(network.Layers[l-1]), delta)

        return Derivative{
                Delta:      delta,
                Adjustment: weights,
        }
}</span>

// ComputeDerivatives returns the derivatives of a specific layer l defined by i
func (network Network) ComputeDerivatives(i int, derivatives []Derivative) Derivative <span class="cov0" title="0">{
        l := len(network.Layers) - 2 - i

        // Compute derivative for the layer of weights and biases
        delta := Multiplication(
                DotProduct(
                        derivatives[i].Delta,
                        Transpose(network.Weights[l]),
                ),
                Multiplication(
                        network.Layers[l],
                        ApplyFunction(network.Layers[l], SubtractsOne),
                ),
        )
        weights := DotProduct(Transpose(network.Layers[l-1]), delta)

        return Derivative{
                Delta:      delta,
                Adjustment: weights,
        }
}</span>

// Adjust make the adjusts
func (network Network) Adjust(derivatives []Derivative) <span class="cov0" title="0">{
        for i, derivative := range derivatives </span><span class="cov0" title="0">{
                l := len(derivatives) - i

                network.Weights[l-1] = Sum(
                        network.Weights[l-1],
                        ApplyRate(derivative.Adjustment, network.Rate),
                )
                network.Biases[l-1] = Sum(
                        network.Biases[l-1],
                        ApplyRate(derivative.Delta, network.Rate),
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package network

import "math"

// Sigmoid is the activation function
func Sigmoid(x float64) float64 <span class="cov8" title="1">{
        return 1 / (1 + math.Exp(-x))
}</span>

// MultipliesByTwo takes a float and returns the float multiplied by two
func MultipliesByTwo(x float64) float64 <span class="cov8" title="1">{
        return 2 * x
}</span>

// SubtractsOne takes a float and returns the float subtracted by one
func SubtractsOne(x float64) float64 <span class="cov8" title="1">{
        return x - 1
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package network

import (
        "math/rand"

        "github.com/antoniomralmeida/k2/internal/inits"
)

// Matrix is an alias for [][]float64
type Matrix [][]float64

// RandomMatrix returns the value of a random matrix of *rows* and *columns* dimensions and
// where the values are between *lower* and *upper*.
func RandomMatrix(rows, columns int) (matrix Matrix) <span class="cov8" title="1">{
        matrix = make(Matrix, rows)

        for i := 0; i &lt; rows; i++ </span><span class="cov8" title="1">{
                matrix[i] = make([]float64, columns)
                for j := 0; j &lt; columns; j++ </span><span class="cov8" title="1">{
                        matrix[i][j] = rand.Float64()*2.0 - 1.0
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

// CreateMatrix returns an empty matrix which is the size of rows and columns
func CreateMatrix(rows, columns int) (matrix Matrix) <span class="cov8" title="1">{
        matrix = make(Matrix, rows)

        for i := 0; i &lt; rows; i++ </span><span class="cov8" title="1">{
                matrix[i] = make([]float64, columns)
        }</span>

        <span class="cov8" title="1">return</span>
}

// Rows returns number of matrix's rows
func Rows(matrix Matrix) int <span class="cov8" title="1">{
        return len(matrix)
}</span>

// Columns returns number of matrix's columns
func Columns(matrix Matrix) int <span class="cov8" title="1">{
        return len(matrix[0])
}</span>

// ApplyFunctionWithIndex returns a matrix where fn has been applied with the indexes provided
func ApplyFunctionWithIndex(matrix Matrix, fn func(i, j int, x float64) float64) Matrix <span class="cov8" title="1">{
        for i := 0; i &lt; Rows(matrix); i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; Columns(matrix); j++ </span><span class="cov8" title="1">{
                        matrix[i][j] = fn(i, j, matrix[i][j])
                }</span>
        }

        <span class="cov8" title="1">return matrix</span>
}

// ApplyFunction returns a matrix where fn has been applied
func ApplyFunction(matrix Matrix, fn func(x float64) float64) Matrix <span class="cov8" title="1">{
        return ApplyFunctionWithIndex(matrix, func(i, j int, x float64) float64 </span><span class="cov8" title="1">{
                return fn(x)
        }</span>)
}

// ApplyRate returns a matrix where the learning rate has been multiplies
func ApplyRate(matrix Matrix, rate float64) Matrix <span class="cov8" title="1">{
        return ApplyFunction(matrix, func(x float64) float64 </span><span class="cov8" title="1">{
                return rate * x
        }</span>)
}

// DotProduct returns a matrix which is the result of the dot product between matrix and matrix2
func DotProduct(matrix, matrix2 Matrix) Matrix <span class="cov8" title="1">{
        if Columns(matrix) != Rows(matrix2) </span><span class="cov0" title="0">{
                inits.Log("Cannot make dot product between these two matrix.", inits.Fatal)
        }</span>

        <span class="cov8" title="1">return ApplyFunctionWithIndex(
                CreateMatrix(Rows(matrix), Columns(matrix2)),
                func(i, j int, x float64) float64 </span><span class="cov8" title="1">{
                        var sum float64

                        for k := 0; k &lt; Columns(matrix); k++ </span><span class="cov8" title="1">{
                                sum += matrix[i][k] * matrix2[k][j]
                        }</span>

                        <span class="cov8" title="1">return sum</span>
                },
        )
}

// Sum returns the sum of matrix and matrix2
func Sum(matrix, matrix2 Matrix) (resultMatrix Matrix) <span class="cov8" title="1">{
        ErrorNotSameSize(matrix, matrix2)

        resultMatrix = CreateMatrix(Rows(matrix), Columns(matrix))

        return ApplyFunctionWithIndex(matrix, func(i, j int, x float64) float64 </span><span class="cov8" title="1">{
                return matrix[i][j] + matrix2[i][j]
        }</span>)
}

// Difference returns the difference between matrix and matrix2
func Difference(matrix, matrix2 Matrix) (resultMatrix Matrix) <span class="cov8" title="1">{
        ErrorNotSameSize(matrix, matrix2)

        resultMatrix = CreateMatrix(Rows(matrix), Columns(matrix))

        return ApplyFunctionWithIndex(resultMatrix, func(i, j int, x float64) float64 </span><span class="cov8" title="1">{
                return matrix[i][j] - matrix2[i][j]
        }</span>)
}

// Multiplication returns the multiplication of matrix and matrix2
func Multiplication(matrix, matrix2 Matrix) (resultMatrix Matrix) <span class="cov8" title="1">{
        ErrorNotSameSize(matrix, matrix2)

        resultMatrix = CreateMatrix(Rows(matrix), Columns(matrix))

        return ApplyFunctionWithIndex(matrix, func(i, j int, x float64) float64 </span><span class="cov8" title="1">{
                return matrix[i][j] * matrix2[i][j]
        }</span>)
}

// Transpose returns the matrix transposed
func Transpose(matrix Matrix) (resultMatrix Matrix) <span class="cov8" title="1">{
        resultMatrix = CreateMatrix(Columns(matrix), Rows(matrix))

        for i := 0; i &lt; Rows(matrix); i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; Columns(matrix); j++ </span><span class="cov8" title="1">{
                        resultMatrix[j][i] = matrix[i][j]
                }</span>
        }

        <span class="cov8" title="1">return resultMatrix</span>
}

// ErrorNotSameSize panics if the matrices do not have the same dimension
func ErrorNotSameSize(matrix, matrix2 Matrix) <span class="cov8" title="1">{
        if Rows(matrix) != Rows(matrix2) &amp;&amp; Columns(matrix) != Columns(matrix2) </span><span class="cov0" title="0">{
                inits.Log("These two matrices must have the same dimension.", inits.Fatal)
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package network

import (
        "encoding/json"
        "fmt"
        "math"
        "os"
        "time"

        "github.com/antoniomralmeida/k2/internal/inits"
        "github.com/antoniomralmeida/k2/internal/olivia/locales"

        "github.com/gookit/color"
        "gopkg.in/cheggaaa/pb.v1"
)

// Network contains the Layers, Weights, Biases of a neural network then the actual output values
// and the learning rate.
type Network struct {
        Layers  []Matrix
        Weights []Matrix
        Biases  []Matrix
        Output  Matrix
        Rate    float64
        Errors  []float64
        Time    float64
        Locale  string
}

// LoadNetwork returns a Network from a specified file
func LoadNetwork(fileName string) *Network <span class="cov0" title="0">{
        inF, err := os.Open(fileName)
        if err != nil </span><span class="cov0" title="0">{
                inits.Log("Failed to load "+fileName+".", inits.Fatal)

        }</span>
        <span class="cov0" title="0">defer inF.Close()

        decoder := json.NewDecoder(inF)
        neuralNetwork := &amp;Network{}
        err = decoder.Decode(neuralNetwork)
        if err != nil </span><span class="cov0" title="0">{
                inits.Log(err, inits.Fatal)
        }</span>

        <span class="cov0" title="0">return neuralNetwork</span>
}

// CreateNetwork creates the network by generating the layers, weights and biases
func CreateNetwork(locale string, rate float64, input, output Matrix, hiddensNodes ...int) Network <span class="cov0" title="0">{
        input = append([][]float64{
                make([]float64, len(input[0])),
        }, input...)
        output = append([][]float64{
                make([]float64, len(output[0])),
        }, output...)

        // Create the layers arrays and add the input values
        inputMatrix := input
        layers := []Matrix{inputMatrix}
        // Generate the hidden layer
        for _, hiddenNodes := range hiddensNodes </span><span class="cov0" title="0">{
                layers = append(layers, CreateMatrix(len(input), hiddenNodes))
        }</span>
        // Add the output values to the layers arrays
        <span class="cov0" title="0">layers = append(layers, output)

        // Generate the weights and biases
        weightsNumber := len(layers) - 1
        var weights []Matrix
        var biases []Matrix

        for i := 0; i &lt; weightsNumber; i++ </span><span class="cov0" title="0">{
                rows, columns := Columns(layers[i]), Columns(layers[i+1])

                weights = append(weights, RandomMatrix(rows, columns))
                biases = append(biases, RandomMatrix(Rows(layers[i]), columns))
        }</span>

        <span class="cov0" title="0">return Network{
                Layers:  layers,
                Weights: weights,
                Biases:  biases,
                Output:  output,
                Rate:    rate,
                Locale:  locale,
        }</span>
}

// Save saves the neural network in a specified file which can be retrieved with LoadNetwork
func (network Network) Save(fileName string) <span class="cov0" title="0">{
        outF, err := os.OpenFile(fileName, os.O_CREATE|os.O_RDWR, 0777)
        if err != nil </span><span class="cov0" title="0">{
                inits.Log("Failed to save the network to "+fileName+".", inits.Fatal)
        }</span>
        <span class="cov0" title="0">defer outF.Close()

        encoder := json.NewEncoder(outF)
        err = encoder.Encode(network)
        if err != nil </span><span class="cov0" title="0">{
                inits.Log(err, inits.Fatal)

        }</span>
}

// FeedForward executes forward propagation for the given inputs in the network
func (network *Network) FeedForward() <span class="cov0" title="0">{
        for i := 0; i &lt; len(network.Layers)-1; i++ </span><span class="cov0" title="0">{
                layer, weights, biases := network.Layers[i], network.Weights[i], network.Biases[i]

                productMatrix := DotProduct(layer, weights)
                Sum(productMatrix, biases)
                ApplyFunction(productMatrix, Sigmoid)

                // Replace the output values
                network.Layers[i+1] = productMatrix
        }</span>
}

// Predict returns the predicted value for a training example
func (network *Network) Predict(input []float64) []float64 <span class="cov0" title="0">{
        network.Layers[0] = Matrix{input}
        network.FeedForward()
        return network.Layers[len(network.Layers)-1][0]
}</span>

// FeedBackward executes back propagation to adjust the weights for all the layers
func (network *Network) FeedBackward() <span class="cov0" title="0">{
        var derivatives []Derivative
        derivatives = append(derivatives, network.ComputeLastLayerDerivatives())

        // Compute the derivatives of the hidden layers
        for i := 0; i &lt; len(network.Layers)-2; i++ </span><span class="cov0" title="0">{
                derivatives = append(derivatives, network.ComputeDerivatives(i, derivatives))
        }</span>

        // Then adjust the weights and biases
        <span class="cov0" title="0">network.Adjust(derivatives)</span>
}

// ComputeError returns the average of all the errors after the training
func (network *Network) ComputeError() float64 <span class="cov0" title="0">{
        // Feed forward to compute the last layer's values
        network.FeedForward()
        lastLayer := network.Layers[len(network.Layers)-1]
        errors := Difference(network.Output, lastLayer)

        // Make the sum of all the errors
        var i int
        var sum float64
        for _, a := range errors </span><span class="cov0" title="0">{
                for _, e := range a </span><span class="cov0" title="0">{
                        sum += e
                        i++
                }</span>
        }

        // Compute the average
        <span class="cov0" title="0">return sum / float64(i)</span>
}

// Train trains the neural network with a given number of iterations by executing
// forward and back propagation
func (network *Network) Train(iterations int) <span class="cov0" title="0">{
        // Initialize the start date
        start := time.Now()

        // Create the progress bar
        bar := pb.New(iterations).Postfix(fmt.Sprintf(
                " - %s %s %s",
                color.FgBlue.Render("Training the"),
                color.FgRed.Render(locales.GetNameByTag(network.Locale)),
                color.FgBlue.Render("neural network"),
        ))
        bar.Format("(██░)")
        bar.SetMaxWidth(60)
        bar.ShowCounters = false
        bar.Start()

        // Train the network
        for i := 0; i &lt; iterations; i++ </span><span class="cov0" title="0">{
                network.FeedForward()
                network.FeedBackward()

                // Append errors for dashboard data
                if i%(iterations/20) == 0 </span><span class="cov0" title="0">{
                        network.Errors = append(
                                network.Errors,
                                // Round the error to two decimals
                                network.ComputeError(),
                        )
                }</span>

                // Increment the progress bar
                <span class="cov0" title="0">bar.Increment()</span>
        }

        <span class="cov0" title="0">bar.Finish()
        // Print the error
        arrangedError := fmt.Sprintf("%.5f", network.ComputeError())

        // Calculate elapsed date
        elapsed := time.Since(start)
        // Round the elapsed date at two decimals
        network.Time = math.Floor(elapsed.Seconds()*100) / 100

        fmt.Printf("The error rate is %s.\n", color.FgGreen.Render(arrangedError))</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package user

import (
        "golang.org/x/oauth2"
)

// Information is the user's information retrieved from the client
type Information struct {
        Name           string        `json:"name"`
        MovieGenres    []string      `json:"movie_genres"`
        MovieBlacklist []string      `json:"movie_blacklist"`
        Reminders      []Reminder    `json:"reminders"`
        SpotifyToken   *oauth2.Token `json:"spotify_token"`
        SpotifyID      string        `json:"spotify_id"`
        SpotifySecret  string        `json:"spotify_secret"`
}

// A Reminder is something the user asked for Olivia to remember
type Reminder struct {
        Reason string `json:"reason"`
        Date   string `json:"date"`
}

// userInformation is a map which is the cache for user information
var userInformation = map[string]Information{}

// ChangeUserInformation requires the token of the user and a function which gives the actual
// information and returns the new information.
func ChangeUserInformation(token string, changer func(Information) Information) <span class="cov8" title="1">{
        userInformation[token] = changer(userInformation[token])
}</span>

// SetUserInformation sets the user's information by its token.
func SetUserInformation(token string, information Information) <span class="cov8" title="1">{
        userInformation[token] = information
}</span>

// GetUserInformation returns the information of a user with his token
func GetUserInformation(token string) Information <span class="cov8" title="1">{
        return userInformation[token]
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
